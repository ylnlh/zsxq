import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as i,f as d}from"./app-tt0ZouaX.js";const r={},n=d(`<p>​</p><h1 id="day-05-web-apis" tabindex="-1"><a class="header-anchor" href="#day-05-web-apis" aria-hidden="true">#</a> day 05 - Web APIs</h1><h5 id="学习目标" tabindex="-1"><a class="header-anchor" href="#学习目标" aria-hidden="true">#</a> 学习目标:</h5><h5 id="能够说出常见-offset-系列属性的作用" tabindex="-1"><a class="header-anchor" href="#能够说出常见-offset-系列属性的作用" aria-hidden="true">#</a> 能够说出常见 offset 系列属性的作用</h5><h5 id="能够说出常见-client-系列属性的作用" tabindex="-1"><a class="header-anchor" href="#能够说出常见-client-系列属性的作用" aria-hidden="true">#</a> 能够说出常见 client 系列属性的作用</h5><h5 id="能够说出常见-scroll-系列属性的作用" tabindex="-1"><a class="header-anchor" href="#能够说出常见-scroll-系列属性的作用" aria-hidden="true">#</a> 能够说出常见 scroll 系列属性的作用</h5><h5 id="能够封装简单动画函数" tabindex="-1"><a class="header-anchor" href="#能够封装简单动画函数" aria-hidden="true">#</a> 能够封装简单动画函数</h5><h2 id="_1-1-元素偏移量-offset-系列" tabindex="-1"><a class="header-anchor" href="#_1-1-元素偏移量-offset-系列" aria-hidden="true">#</a> 1. 1. 元素偏移量 offset 系列</h2><h2 id="_1-1-1-offset-概述" tabindex="-1"><a class="header-anchor" href="#_1-1-1-offset-概述" aria-hidden="true">#</a> 1. 1. 1 offset 概述</h2><h5 id="offset-翻译过来就是偏移量-我们使用-offset系列相关属性可以动态的得到该元素的位置-偏移-、大小等。" tabindex="-1"><a class="header-anchor" href="#offset-翻译过来就是偏移量-我们使用-offset系列相关属性可以动态的得到该元素的位置-偏移-、大小等。" aria-hidden="true">#</a> offset 翻译过来就是偏移量， 我们使用 offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</h5><h5 id="_1-获得元素距离带有定位父元素的位置" tabindex="-1"><a class="header-anchor" href="#_1-获得元素距离带有定位父元素的位置" aria-hidden="true">#</a> 1. 获得元素距离带有定位父元素的位置</h5><h5 id="_2-获得元素自身的大小-宽度高度" tabindex="-1"><a class="header-anchor" href="#_2-获得元素自身的大小-宽度高度" aria-hidden="true">#</a> 2. 获得元素自身的大小（宽度高度）</h5><h5 id="_3-注意-返回的数值都不带单位" tabindex="-1"><a class="header-anchor" href="#_3-注意-返回的数值都不带单位" aria-hidden="true">#</a> 3. 注意：返回的数值都不带单位</h5><h5 id="图片-2" tabindex="-1"><a class="header-anchor" href="#图片-2" aria-hidden="true">#</a> 图片 2</h5><h2 id="_1-1-2-offset-与-style-区别" tabindex="-1"><a class="header-anchor" href="#_1-1-2-offset-与-style-区别" aria-hidden="true">#</a> 1. 1. 2 offset 与 style 区别</h2><h4 id="offset" tabindex="-1"><a class="header-anchor" href="#offset" aria-hidden="true">#</a> offset</h4><h5 id="offset-可以得到任意样式表中的样式值" tabindex="-1"><a class="header-anchor" href="#offset-可以得到任意样式表中的样式值" aria-hidden="true">#</a> offset 可以得到任意样式表中的样式值</h5><h5 id="offset-系列获得的数值是没有单位的" tabindex="-1"><a class="header-anchor" href="#offset-系列获得的数值是没有单位的" aria-hidden="true">#</a> offset 系列获得的数值是没有单位的</h5><h5 id="offsetwidth-包含padding-border-width" tabindex="-1"><a class="header-anchor" href="#offsetwidth-包含padding-border-width" aria-hidden="true">#</a> offsetWidth 包含padding+border+width</h5><h5 id="offsetwidth-等属性是只读属性-只能获取不能赋值" tabindex="-1"><a class="header-anchor" href="#offsetwidth-等属性是只读属性-只能获取不能赋值" aria-hidden="true">#</a> offsetWidth 等属性是只读属性，只能获取不能赋值</h5><h5 id="所以-我们想要获取元素大小位置-用offset更合适" tabindex="-1"><a class="header-anchor" href="#所以-我们想要获取元素大小位置-用offset更合适" aria-hidden="true">#</a> 所以，我们想要获取元素大小位置，用offset更合适</h5><h4 id="style" tabindex="-1"><a class="header-anchor" href="#style" aria-hidden="true">#</a> style</h4><h5 id="style-只能得到行内样式表中的样式值" tabindex="-1"><a class="header-anchor" href="#style-只能得到行内样式表中的样式值" aria-hidden="true">#</a> style 只能得到行内样式表中的样式值</h5><h5 id="style-width-获得的是带有单位的字符串" tabindex="-1"><a class="header-anchor" href="#style-width-获得的是带有单位的字符串" aria-hidden="true">#</a> style.width 获得的是带有单位的字符串</h5><h5 id="style-width-获得不包含padding和border-的值" tabindex="-1"><a class="header-anchor" href="#style-width-获得不包含padding和border-的值" aria-hidden="true">#</a> style.width 获得不包含padding和border 的值</h5><h5 id="style-width-是可读写属性-可以获取也可以赋值" tabindex="-1"><a class="header-anchor" href="#style-width-是可读写属性-可以获取也可以赋值" aria-hidden="true">#</a> style.width 是可读写属性，可以获取也可以赋值</h5><h5 id="所以-我们想要给元素更改值-则需要用style改变" tabindex="-1"><a class="header-anchor" href="#所以-我们想要给元素更改值-则需要用style改变" aria-hidden="true">#</a> 所以，我们想要给元素更改值，则需要用style改变</h5><h5 id="因为平时我们都是给元素注册触摸事件-所以重点记住-targettocuhes" tabindex="-1"><a class="header-anchor" href="#因为平时我们都是给元素注册触摸事件-所以重点记住-targettocuhes" aria-hidden="true">#</a> 因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes</h5><h3 id="_1-1-3-案例-获取鼠标在盒子内的坐标" tabindex="-1"><a class="header-anchor" href="#_1-1-3-案例-获取鼠标在盒子内的坐标" aria-hidden="true">#</a> 1. 1. 3 案例：获取鼠标在盒子内的坐标</h3><h5 id="_1-我们在盒子内点击-想要得到鼠标距离盒子左右的距离。" tabindex="-1"><a class="header-anchor" href="#_1-我们在盒子内点击-想要得到鼠标距离盒子左右的距离。" aria-hidden="true">#</a> 1. 我们在盒子内点击，想要得到鼠标距离盒子左右的距离。</h5><h5 id="_2-首先得到鼠标在页面中的坐标-e-pagex-e-pagey" tabindex="-1"><a class="header-anchor" href="#_2-首先得到鼠标在页面中的坐标-e-pagex-e-pagey" aria-hidden="true">#</a> 2. 首先得到鼠标在页面中的坐标（e.pageX, e.pageY）</h5><h5 id="_3-其次得到盒子在页面中的距离-box-offsetleft-box-offsettop" tabindex="-1"><a class="header-anchor" href="#_3-其次得到盒子在页面中的距离-box-offsetleft-box-offsettop" aria-hidden="true">#</a> 3. 其次得到盒子在页面中的距离 ( box.offsetLeft, box.offsetTop)</h5><h5 id="_4-用鼠标距离页面的坐标减去盒子在页面中的距离-得到-鼠标在盒子内的坐标" tabindex="-1"><a class="header-anchor" href="#_4-用鼠标距离页面的坐标减去盒子在页面中的距离-得到-鼠标在盒子内的坐标" aria-hidden="true">#</a> 4. 用鼠标距离页面的坐标减去盒子在页面中的距离，得到 鼠标在盒子内的坐标</h5><h5 id="_5-如果想要移动一下鼠标-就要获取最新的坐标-使用鼠标移动" tabindex="-1"><a class="header-anchor" href="#_5-如果想要移动一下鼠标-就要获取最新的坐标-使用鼠标移动" aria-hidden="true">#</a> 5. 如果想要移动一下鼠标，就要获取最新的坐标，使用鼠标移动</h5><h3 id="_1-1-4-案例-模态框拖拽" tabindex="-1"><a class="header-anchor" href="#_1-1-4-案例-模态框拖拽" aria-hidden="true">#</a> 1. 1. 4 案例：模态框拖拽</h3><h5 id="弹出框-我们也称为模态框。" tabindex="-1"><a class="header-anchor" href="#弹出框-我们也称为模态框。" aria-hidden="true">#</a> 弹出框，我们也称为模态框。</h5><h5 id="_1-点击弹出层-会弹出模态框-并且显示灰色半透明的遮挡层。" tabindex="-1"><a class="header-anchor" href="#_1-点击弹出层-会弹出模态框-并且显示灰色半透明的遮挡层。" aria-hidden="true">#</a> 1.点击弹出层，会弹出模态框， 并且显示灰色半透明的遮挡层。</h5><h5 id="_2-点击关闭按钮-可以关闭模态框-并且同时关闭灰色半透明遮挡层。" tabindex="-1"><a class="header-anchor" href="#_2-点击关闭按钮-可以关闭模态框-并且同时关闭灰色半透明遮挡层。" aria-hidden="true">#</a> 2.点击关闭按钮，可以关闭模态框，并且同时关闭灰色半透明遮挡层。</h5><h5 id="_3-鼠标放到模态框最上面一行-可以按住鼠标拖拽模态框在页面中移动。" tabindex="-1"><a class="header-anchor" href="#_3-鼠标放到模态框最上面一行-可以按住鼠标拖拽模态框在页面中移动。" aria-hidden="true">#</a> 3.鼠标放到模态框最上面一行，可以按住鼠标拖拽模态框在页面中移动。</h5><h5 id="_4-鼠标松开-可以停止拖动模态框移动" tabindex="-1"><a class="header-anchor" href="#_4-鼠标松开-可以停止拖动模态框移动" aria-hidden="true">#</a> 4.鼠标松开，可以停止拖动模态框移动</h5><h3 id="_1-1-5-案例分析" tabindex="-1"><a class="header-anchor" href="#_1-1-5-案例分析" aria-hidden="true">#</a> 1. 1. 5. 案例分析:</h3><h5 id="_1-点击弹出层-模态框和遮挡层就会显示出来-display-block" tabindex="-1"><a class="header-anchor" href="#_1-点击弹出层-模态框和遮挡层就会显示出来-display-block" aria-hidden="true">#</a> 1. 点击弹出层， 模态框和遮挡层就会显示出来 display:block;</h5><h5 id="_2-点击关闭按钮-模态框和遮挡层就会隐藏起来-display-none" tabindex="-1"><a class="header-anchor" href="#_2-点击关闭按钮-模态框和遮挡层就会隐藏起来-display-none" aria-hidden="true">#</a> 2. 点击关闭按钮，模态框和遮挡层就会隐藏起来 display:none;</h5><h5 id="_3-在页面中拖拽的原理-鼠标按下并且移动-之后松开鼠标" tabindex="-1"><a class="header-anchor" href="#_3-在页面中拖拽的原理-鼠标按下并且移动-之后松开鼠标" aria-hidden="true">#</a> 3. 在页面中拖拽的原理：鼠标按下并且移动， 之后松开鼠标</h5><h5 id="_4-触发事件是鼠标按下mousedown-鼠标移动mousemove-鼠标松开-mouseup" tabindex="-1"><a class="header-anchor" href="#_4-触发事件是鼠标按下mousedown-鼠标移动mousemove-鼠标松开-mouseup" aria-hidden="true">#</a> 4. 触发事件是鼠标按下mousedown，鼠标移动mousemove 鼠标松开 mouseup</h5><h5 id="_5-拖拽过程-鼠标移动过程中-获得最新的值赋值给模态框的left和top值-这样模态框可以跟着鼠标走了" tabindex="-1"><a class="header-anchor" href="#_5-拖拽过程-鼠标移动过程中-获得最新的值赋值给模态框的left和top值-这样模态框可以跟着鼠标走了" aria-hidden="true">#</a> 5. 拖拽过程:  鼠标移动过程中，获得最新的值赋值给模态框的left和top值，这样模态框可以跟着鼠标走了</h5><h5 id="_6-鼠标按下触发的事件源是最上面一行-就是-id-为-title" tabindex="-1"><a class="header-anchor" href="#_6-鼠标按下触发的事件源是最上面一行-就是-id-为-title" aria-hidden="true">#</a> 6. 鼠标按下触发的事件源是最上面一行，就是  id 为 title</h5><h5 id="_7-鼠标的坐标减去-鼠标在盒子内的坐标-才是模态框真正的位置。" tabindex="-1"><a class="header-anchor" href="#_7-鼠标的坐标减去-鼠标在盒子内的坐标-才是模态框真正的位置。" aria-hidden="true">#</a> 7. 鼠标的坐标减去 鼠标在盒子内的坐标， 才是模态框真正的位置。</h5><h5 id="_8-鼠标按下-我们要得到鼠标在盒子的坐标。" tabindex="-1"><a class="header-anchor" href="#_8-鼠标按下-我们要得到鼠标在盒子的坐标。" aria-hidden="true">#</a> 8. 鼠标按下，我们要得到鼠标在盒子的坐标。</h5><h5 id="_9-鼠标移动-就让模态框的坐标-设置为-鼠标坐标-减去盒子坐标即可-注意移动事件写到按下事件里面。" tabindex="-1"><a class="header-anchor" href="#_9-鼠标移动-就让模态框的坐标-设置为-鼠标坐标-减去盒子坐标即可-注意移动事件写到按下事件里面。" aria-hidden="true">#</a> 9. 鼠标移动，就让模态框的坐标 设置为 ：鼠标坐标 减去盒子坐标即可，注意移动事件写到按下事件里面。</h5><h5 id="_10-鼠标松开-就停止拖拽-就是可以让鼠标移动事件解除" tabindex="-1"><a class="header-anchor" href="#_10-鼠标松开-就停止拖拽-就是可以让鼠标移动事件解除" aria-hidden="true">#</a> 10. 鼠标松开，就停止拖拽，就是可以让鼠标移动事件解除</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var box = document.querySelector(&#39;.box&#39;);
box.addEventListener(&#39;mousemove&#39;, function(e) {
var x = e.pageX ­ this.offsetLeft;
var y = e.pageY ­ this.offsetTop;
this.innerHTML = &#39;x坐标是&#39; + x + &#39; y坐标是&#39; + y;
})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-1-6-案例-仿京东放大镜" tabindex="-1"><a class="header-anchor" href="#_1-1-6-案例-仿京东放大镜" aria-hidden="true">#</a> 1. 1. 6 案例：仿京东放大镜</h3><h5 id="_1-整个案例可以分为三个功能模块" tabindex="-1"><a class="header-anchor" href="#_1-整个案例可以分为三个功能模块" aria-hidden="true">#</a> 1. 整个案例可以分为三个功能模块</h5><h5 id="_2-鼠标经过小图片盒子-黄色的遮挡层-和-大图片盒子显示-离开隐藏-2-个盒子功能" tabindex="-1"><a class="header-anchor" href="#_2-鼠标经过小图片盒子-黄色的遮挡层-和-大图片盒子显示-离开隐藏-2-个盒子功能" aria-hidden="true">#</a> 2. 鼠标经过小图片盒子， 黄色的遮挡层 和 大图片盒子显示，离开隐藏 2 个盒子功能</h5><h5 id="_3-黄色的遮挡层跟随鼠标功能。" tabindex="-1"><a class="header-anchor" href="#_3-黄色的遮挡层跟随鼠标功能。" aria-hidden="true">#</a> 3. 黄色的遮挡层跟随鼠标功能。</h5><h5 id="_4-移动黄色遮挡层-大图片跟随移动功能。" tabindex="-1"><a class="header-anchor" href="#_4-移动黄色遮挡层-大图片跟随移动功能。" aria-hidden="true">#</a> 4. 移动黄色遮挡层，大图片跟随移动功能。</h5><h3 id="_1-1-7-案例分析" tabindex="-1"><a class="header-anchor" href="#_1-1-7-案例分析" aria-hidden="true">#</a> 1. 1. 7. 案例分析:</h3><h6 id="_1-获取元素" tabindex="-1"><a class="header-anchor" href="#_1-获取元素" aria-hidden="true">#</a> // 1. 获取元素</h6><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var login = document.querySelector(&#39;.login&#39;);
var mask = document.querySelector(&#39;.login­bg&#39;);
var link = document.querySelector(&#39;#link&#39;);
var closeBtn = document.querySelector(&#39;#closeBtn&#39;);
var title = document.querySelector(&#39;#title&#39;);
// 2. 点击弹出层这个链接 link  让mask 和login 显示出来
link.addEventListener(&#39;click&#39;, function() {
mask.style.display = &#39;block&#39;;
login.style.display = &#39;block&#39;;
            })
// 3. 点击 closeBtn 就隐藏 mask 和 login
closeBtn.addEventListener(&#39;click&#39;, function() {
mask.style.display = &#39;none&#39;;
login.style.display = &#39;none&#39;;
            })
// 4. 开始拖拽
// (1) 当我们鼠标按下， 就获得鼠标在盒子内的坐标
title.addEventListener(&#39;mousedown&#39;, function(e) {
var x = e.pageX ­ login.offsetLeft;
var y = e.pageY ­ login.offsetTop;
// (2) 鼠标移动的时候，把鼠标在页面中的坐标，减去 鼠标在盒子内的坐标就是模态框的left和
top值
document.addEventListener(&#39;mousemove&#39;, move)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function move(e) {
login.style.left = e.pageX ­ x + &#39;px&#39;;
login.style.top = e.pageY ­ y + &#39;px&#39;;
            }
// (3) 鼠标弹起，就让鼠标移动事件移除
document.addEventListener(&#39;mouseup&#39;, function() {
document.removeEventListener(&#39;mousemove&#39;, move);
            })
        })
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_1-黄色的遮挡层跟随鼠标功能。" tabindex="-1"><a class="header-anchor" href="#_1-黄色的遮挡层跟随鼠标功能。" aria-hidden="true">#</a> 1. 黄色的遮挡层跟随鼠标功能。</h5><h5 id="_2-把鼠标坐标给遮挡层不合适。因为遮挡层坐标以父盒子为准。" tabindex="-1"><a class="header-anchor" href="#_2-把鼠标坐标给遮挡层不合适。因为遮挡层坐标以父盒子为准。" aria-hidden="true">#</a> 2. 把鼠标坐标给遮挡层不合适。因为遮挡层坐标以父盒子为准。</h5><h5 id="_3-首先是获得鼠标在盒子的坐标。" tabindex="-1"><a class="header-anchor" href="#_3-首先是获得鼠标在盒子的坐标。" aria-hidden="true">#</a> 3. 首先是获得鼠标在盒子的坐标。</h5><h5 id="_4-之后把数值给遮挡层做为left-和top值。" tabindex="-1"><a class="header-anchor" href="#_4-之后把数值给遮挡层做为left-和top值。" aria-hidden="true">#</a> 4. 之后把数值给遮挡层做为left 和top值。</h5><h5 id="_5-此时用到鼠标移动事件-但是还是在小图片盒子内移动。" tabindex="-1"><a class="header-anchor" href="#_5-此时用到鼠标移动事件-但是还是在小图片盒子内移动。" aria-hidden="true">#</a> 5. 此时用到鼠标移动事件，但是还是在小图片盒子内移动。</h5><h5 id="_6-发现-遮挡层位置不对-需要再减去盒子自身高度和宽度的一半。" tabindex="-1"><a class="header-anchor" href="#_6-发现-遮挡层位置不对-需要再减去盒子自身高度和宽度的一半。" aria-hidden="true">#</a> 6. 发现，遮挡层位置不对，需要再减去盒子自身高度和宽度的一半。</h5><h5 id="_7-遮挡层不能超出小图片盒子范围。" tabindex="-1"><a class="header-anchor" href="#_7-遮挡层不能超出小图片盒子范围。" aria-hidden="true">#</a> 7. 遮挡层不能超出小图片盒子范围。</h5><h5 id="_8-如果小于零-就把坐标设置为-0" tabindex="-1"><a class="header-anchor" href="#_8-如果小于零-就把坐标设置为-0" aria-hidden="true">#</a> 8. 如果小于零，就把坐标设置为 0</h5><h5 id="_9-如果大于遮挡层最大的移动距离-就把坐标设置为最大的移动距离" tabindex="-1"><a class="header-anchor" href="#_9-如果大于遮挡层最大的移动距离-就把坐标设置为最大的移动距离" aria-hidden="true">#</a> 9. 如果大于遮挡层最大的移动距离，就把坐标设置为最大的移动距离</h5><h5 id="_10-遮挡层的最大移动距离-小图片盒子宽度-减去-遮挡层盒子宽度" tabindex="-1"><a class="header-anchor" href="#_10-遮挡层的最大移动距离-小图片盒子宽度-减去-遮挡层盒子宽度" aria-hidden="true">#</a> 10. 遮挡层的最大移动距离：小图片盒子宽度 减去 遮挡层盒子宽度</h5><h5 id="_1551881487-1" tabindex="-1"><a class="header-anchor" href="#_1551881487-1" aria-hidden="true">#</a> 1551881487(1)</h5><h5 id="_1551881563-1" tabindex="-1"><a class="header-anchor" href="#_1551881563-1" aria-hidden="true">#</a> 1551881563(1)</h5><p>window.addEventListener(&#39;load&#39;, function() { var preview_img = document.querySelector(&#39;.preview_img&#39;); var mask = document.querySelector(&#39;.mask&#39;); var big = document.querySelector(&#39;.big&#39;); // 1. 当我们鼠标经过 preview_img 就显示和隐藏 mask 遮挡层 和 big 大盒子 preview_img.addEventListener(&#39;mouseover&#39;, function() { mask.style.display = &#39;block&#39;; big.style.display = &#39;block&#39;;     }) preview_img.addEventListener(&#39;mouseout&#39;, function() { mask.style.display = &#39;none&#39;; big.style.display = &#39;none&#39;;         }) // 2. 鼠标移动的时候，让黄色的盒子跟着鼠标来走 preview_img.addEventListener(&#39;mousemove&#39;, function(e) { // (1). 先计算出鼠标在盒子内的坐标 var x = e.pageX ­ this.offsetLeft; var y = e.pageY ­ this.offsetTop; // console.log(x, y); // (2) 减去盒子高度  300 的一半 是  150  就是我们mask 的最终 left 和top值了 // (3) 我们mask 移动的距离 var maskX = x ­ mask.offsetWidth /  2 ; var maskY = y ­ mask.offsetHeight /  2 ; // (4) 如果x 坐标小于了 0  就让他停在 0  的位置 // 遮挡层的最大移动距离 var maskMax = preview_img.offsetWidth ­ mask.offsetWidth; if (maskX &lt;=  0 ) { maskX =  0 ;         } else if (maskX &gt;= maskMax) { maskX = maskMax;         } if (maskY &lt;=  0 ) { maskY =  0 ;         } else if (maskY &gt;= maskMax) { maskY = maskMax;         } mask.style.left = maskX + &#39;px&#39;; mask.style.top = maskY + &#39;px&#39;; // 3. 大图片的移动距离 = 遮挡层移动距离 * 大图片最大移动距离 / 遮挡层的最大移动距离 // 大图 var bigIMg = document.querySelector(&#39;.bigImg&#39;); // 大图片最大移动距离 var bigMax = bigIMg.offsetWidth ­ big.offsetWidth; // 大图片的移动距离 X Y var bigX = maskX * bigMax / maskMax; var bigY = maskY * bigMax / maskMax; bigIMg.style.left = ­bigX + &#39;px&#39;; bigIMg.style.top = ­bigY + &#39;px&#39;;</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    })
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>})
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_1-2-元素可视区-client-系列" tabindex="-1"><a class="header-anchor" href="#_1-2-元素可视区-client-系列" aria-hidden="true">#</a> 1. 2. 元素可视区 client 系列</h2><h3 id="_1-2-1-client概述" tabindex="-1"><a class="header-anchor" href="#_1-2-1-client概述" aria-hidden="true">#</a> 1. 2. 1 client概述</h3><h5 id="client-翻译过来就是客户端-我们使用-client-系列的相关属性来获取元素可视区的相关信息。通过-client-系列的相" tabindex="-1"><a class="header-anchor" href="#client-翻译过来就是客户端-我们使用-client-系列的相关属性来获取元素可视区的相关信息。通过-client-系列的相" aria-hidden="true">#</a> client 翻译过来就是客户端，我们使用 client 系列的相关属性来获取元素可视区的相关信息。通过 client 系列的相</h5><h5 id="关属性可以动态的得到该元素的边框大小、元素大小等。" tabindex="-1"><a class="header-anchor" href="#关属性可以动态的得到该元素的边框大小、元素大小等。" aria-hidden="true">#</a> 关属性可以动态的得到该元素的边框大小、元素大小等。</h5><h3 id="_1-2-2-淘宝-flexible-js-源码分析" tabindex="-1"><a class="header-anchor" href="#_1-2-2-淘宝-flexible-js-源码分析" aria-hidden="true">#</a> 1. 2. 2. 淘宝 flexible.js 源码分析</h3><h5 id="立即执行函数-function-或者-function" tabindex="-1"><a class="header-anchor" href="#立即执行函数-function-或者-function" aria-hidden="true">#</a> 立即执行函数 (function(){})()  或者 (function(){}())</h5><h5 id="主要作用-创建一个独立的作用域。-避免了命名冲突问题" tabindex="-1"><a class="header-anchor" href="#主要作用-创建一个独立的作用域。-避免了命名冲突问题" aria-hidden="true">#</a> 主要作用： 创建一个独立的作用域。 避免了命名冲突问题</h5><h5 id="下面三种情况都会刷新页面都会触发-load-事件。" tabindex="-1"><a class="header-anchor" href="#下面三种情况都会刷新页面都会触发-load-事件。" aria-hidden="true">#</a> 下面三种情况都会刷新页面都会触发 load 事件。</h5><h5 id="_1-a标签的超链接" tabindex="-1"><a class="header-anchor" href="#_1-a标签的超链接" aria-hidden="true">#</a> 1.a标签的超链接</h5><h5 id="_2-f5或者刷新按钮-强制刷新" tabindex="-1"><a class="header-anchor" href="#_2-f5或者刷新按钮-强制刷新" aria-hidden="true">#</a> 2.F5或者刷新按钮（强制刷新）</h5><h5 id="_3-前进后退按钮" tabindex="-1"><a class="header-anchor" href="#_3-前进后退按钮" aria-hidden="true">#</a> 3.前进后退按钮</h5><h5 id="但是-火狐中-有个特点-有个-往返缓存-这个缓存中不仅保存着页面数据-还保存了dom和javascript的状态" tabindex="-1"><a class="header-anchor" href="#但是-火狐中-有个特点-有个-往返缓存-这个缓存中不仅保存着页面数据-还保存了dom和javascript的状态" aria-hidden="true">#</a> 但是 火狐中，有个特点，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；</h5><h5 id="实际上是将整个页面都保存在了内存里。" tabindex="-1"><a class="header-anchor" href="#实际上是将整个页面都保存在了内存里。" aria-hidden="true">#</a> 实际上是将整个页面都保存在了内存里。</h5><h5 id="所以此时后退按钮不能刷新页面。" tabindex="-1"><a class="header-anchor" href="#所以此时后退按钮不能刷新页面。" aria-hidden="true">#</a> 所以此时后退按钮不能刷新页面。</h5><h5 id="此时可以使用-pageshow事件来触发。-这个事件在页面显示时触发-无论页面是否来自缓存。在重新加载页面" tabindex="-1"><a class="header-anchor" href="#此时可以使用-pageshow事件来触发。-这个事件在页面显示时触发-无论页面是否来自缓存。在重新加载页面" aria-hidden="true">#</a> 此时可以使用 pageshow事件来触发。，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面</h5><h5 id="中-pageshow会在load事件触发后触发-根据事件对象中的persisted来判断是否是缓存中的页面触发的" tabindex="-1"><a class="header-anchor" href="#中-pageshow会在load事件触发后触发-根据事件对象中的persisted来判断是否是缓存中的页面触发的" aria-hidden="true">#</a> 中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的</h5><h5 id="pageshow事件" tabindex="-1"><a class="header-anchor" href="#pageshow事件" aria-hidden="true">#</a> pageshow事件</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>注意这个事件给window添加。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_1-3-元素滚动-scroll-系列" tabindex="-1"><a class="header-anchor" href="#_1-3-元素滚动-scroll-系列" aria-hidden="true">#</a> 1. 3 .元素滚动 scroll 系列</h2><h3 id="_1-3-1-scroll-概述" tabindex="-1"><a class="header-anchor" href="#_1-3-1-scroll-概述" aria-hidden="true">#</a> 1. 3. 1. scroll 概述</h3><h5 id="scroll-翻译过来就是滚动的-我们使用-scroll-系列的相关属性可以动态的得到该元素的大小、滚动距离等。" tabindex="-1"><a class="header-anchor" href="#scroll-翻译过来就是滚动的-我们使用-scroll-系列的相关属性可以动态的得到该元素的大小、滚动距离等。" aria-hidden="true">#</a> scroll 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等。</h5><h3 id="_1-3-2-页面被卷去的头部" tabindex="-1"><a class="header-anchor" href="#_1-3-2-页面被卷去的头部" aria-hidden="true">#</a> 1. 3. 2. 页面被卷去的头部</h3><h5 id="如果浏览器的高-或宽-度不足以显示整个页面时-会自动出现滚动条。当滚动条向下滚动时-页面上面被隐藏掉" tabindex="-1"><a class="header-anchor" href="#如果浏览器的高-或宽-度不足以显示整个页面时-会自动出现滚动条。当滚动条向下滚动时-页面上面被隐藏掉" aria-hidden="true">#</a> 如果浏览器的高（或宽）度不足以显示整个页面时，会自动出现滚动条。当滚动条向下滚动时，页面上面被隐藏掉</h5><h5 id="的高度-我们就称为页面被卷去的头部。滚动条在滚动时会触发-onscroll事件。" tabindex="-1"><a class="header-anchor" href="#的高度-我们就称为页面被卷去的头部。滚动条在滚动时会触发-onscroll事件。" aria-hidden="true">#</a> 的高度，我们就称为页面被卷去的头部。滚动条在滚动时会触发 onscroll事件。</h5><h3 id="_1-3-3-案例-仿淘宝固定右侧侧边栏" tabindex="-1"><a class="header-anchor" href="#_1-3-3-案例-仿淘宝固定右侧侧边栏" aria-hidden="true">#</a> 1. 3. 3 .案例：仿淘宝固定右侧侧边栏</h3><h5 id="_1-原先侧边栏是绝对定位" tabindex="-1"><a class="header-anchor" href="#_1-原先侧边栏是绝对定位" aria-hidden="true">#</a> 1. 原先侧边栏是绝对定位</h5><h5 id="_2-当页面滚动到一定位置-侧边栏改为固定定位" tabindex="-1"><a class="header-anchor" href="#_2-当页面滚动到一定位置-侧边栏改为固定定位" aria-hidden="true">#</a> 2. 当页面滚动到一定位置，侧边栏改为固定定位</h5><h5 id="_3-页面继续滚动-会让-返回顶部显示出来" tabindex="-1"><a class="header-anchor" href="#_3-页面继续滚动-会让-返回顶部显示出来" aria-hidden="true">#</a> 3. 页面继续滚动，会让 返回顶部显示出来</h5><h3 id="_1-3-4-案例分析" tabindex="-1"><a class="header-anchor" href="#_1-3-4-案例分析" aria-hidden="true">#</a> 1. 3. 4 .案例分析:</h3><h5 id="_1-需要用到页面滚动事件-scroll-因为是页面滚动-所以事件源是document" tabindex="-1"><a class="header-anchor" href="#_1-需要用到页面滚动事件-scroll-因为是页面滚动-所以事件源是document" aria-hidden="true">#</a> 1. 需要用到页面滚动事件 scroll  因为是页面滚动，所以事件源是document</h5><h5 id="_2-滚动到某个位置-就是判断页面被卷去的上部值。" tabindex="-1"><a class="header-anchor" href="#_2-滚动到某个位置-就是判断页面被卷去的上部值。" aria-hidden="true">#</a> 2. 滚动到某个位置，就是判断页面被卷去的上部值。</h5><h5 id="_3-页面被卷去的头部-可以通过window-pageyoffset-获得-如果是被卷去的左侧window-pagexoffset" tabindex="-1"><a class="header-anchor" href="#_3-页面被卷去的头部-可以通过window-pageyoffset-获得-如果是被卷去的左侧window-pagexoffset" aria-hidden="true">#</a> 3. 页面被卷去的头部：可以通过window.pageYOffset 获得 如果是被卷去的左侧window.pageXOffset</h5><h5 id="_4-注意-元素被卷去的头部是element-scrolltop-如果是页面被卷去的头部-则是-window-pageyoffset" tabindex="-1"><a class="header-anchor" href="#_4-注意-元素被卷去的头部是element-scrolltop-如果是页面被卷去的头部-则是-window-pageyoffset" aria-hidden="true">#</a> 4. 注意，元素被卷去的头部是element.scrollTop  , 如果是页面被卷去的头部 则是 window.pageYOffset</h5><h5 id="_5-其实这个值-可以通过盒子的-offsettop可以得到-如果大于等于这个值-就可以让盒子固定定位了" tabindex="-1"><a class="header-anchor" href="#_5-其实这个值-可以通过盒子的-offsettop可以得到-如果大于等于这个值-就可以让盒子固定定位了" aria-hidden="true">#</a> 5. 其实这个值 可以通过盒子的 offsetTop可以得到，如果大于等于这个值，就可以让盒子固定定位了</h5><h3 id="_1-3-5-页面被卷去的头部兼容性解决方案" tabindex="-1"><a class="header-anchor" href="#_1-3-5-页面被卷去的头部兼容性解决方案" aria-hidden="true">#</a> 1. 3. 5 .页面被卷去的头部兼容性解决方案</h3><h5 id="需要注意的是-页面被卷去的头部-有兼容性问题-因此被卷去的头部通常有如下几种写法" tabindex="-1"><a class="header-anchor" href="#需要注意的是-页面被卷去的头部-有兼容性问题-因此被卷去的头部通常有如下几种写法" aria-hidden="true">#</a> 需要注意的是，页面被卷去的头部，有兼容性问题，因此被卷去的头部通常有如下几种写法：</h5><h5 id="_1-声明了-dtd-使用-document-documentelement-scrolltop" tabindex="-1"><a class="header-anchor" href="#_1-声明了-dtd-使用-document-documentelement-scrolltop" aria-hidden="true">#</a> 1. 声明了 DTD，使用 document.documentElement.scrollTop</h5><h5 id="_2-未声明-dtd-使用-document-body-scrolltop" tabindex="-1"><a class="header-anchor" href="#_2-未声明-dtd-使用-document-body-scrolltop" aria-hidden="true">#</a> 2. 未声明 DTD，使用  document.body.scrollTop</h5><h5 id="_3-新方法-window-pageyoffset和-window-pagexoffset-ie9-开始支持" tabindex="-1"><a class="header-anchor" href="#_3-新方法-window-pageyoffset和-window-pagexoffset-ie9-开始支持" aria-hidden="true">#</a> 3. 新方法 window.pageYOffset和 window.pageXOffset，IE9 开始支持</h5><h6 id="_1-获取元素-1" tabindex="-1"><a class="header-anchor" href="#_1-获取元素-1" aria-hidden="true">#</a> //1. 获取元素</h6><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var sliderbar = document.querySelector(&#39;.slider­bar&#39;);
var banner = document.querySelector(&#39;.banner&#39;);
// banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面
var bannerTop = banner.offsetTop
// 当我们侧边栏固定定位之后应该变化的数值
var sliderbarTop = sliderbar.offsetTop ­ bannerTop;
// 获取main 主体元素
var main = document.querySelector(&#39;.main&#39;);
var goBack = document.querySelector(&#39;.goBack&#39;);
var mainTop = main.offsetTop;
// 2. 页面滚动事件 scroll
document.addEventListener(&#39;scroll&#39;, function() {
// console.log(11);
// window.pageYOffset 页面被卷去的头部
// console.log(window.pageYOffset);
// 3 .当我们页面被卷去的头部大于等于了  172  此时 侧边栏就要改为固定定位
if (window.pageYOffset &gt;= bannerTop) {
sliderbar.style.position = &#39;fixed&#39;;
sliderbar.style.top = sliderbarTop + &#39;px&#39;;
            } else {
sliderbar.style.position = &#39;absolute&#39;;
sliderbar.style.top = &#39;300px&#39;;
            }
// 4. 当我们页面滚动到main盒子，就显示 goback模块
if (window.pageYOffset &gt;= mainTop) {
goBack.style.display = &#39;block&#39;;
            } else {
goBack.style.display = &#39;none&#39;;
            }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>        })
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="_1-4-三大系列总结" tabindex="-1"><a class="header-anchor" href="#_1-4-三大系列总结" aria-hidden="true">#</a> 1. 4. 三大系列总结</h2><h5 id="他们主要用法" tabindex="-1"><a class="header-anchor" href="#他们主要用法" aria-hidden="true">#</a> 他们主要用法：</h5><h5 id="_1-offset系列-经常用于获得元素位置-offsetleft-offsettop" tabindex="-1"><a class="header-anchor" href="#_1-offset系列-经常用于获得元素位置-offsetleft-offsettop" aria-hidden="true">#</a> 1.offset系列 经常用于获得元素位置    offsetLeft  offsetTop</h5><h5 id="_2-client经常用于获取元素大小-clientwidth-clientheight" tabindex="-1"><a class="header-anchor" href="#_2-client经常用于获取元素大小-clientwidth-clientheight" aria-hidden="true">#</a> 2.client经常用于获取元素大小  clientWidth clientHeight</h5><h5 id="_3-scroll-经常用于获取滚动距离-scrolltop-scrollleft" tabindex="-1"><a class="header-anchor" href="#_3-scroll-经常用于获取滚动距离-scrolltop-scrollleft" aria-hidden="true">#</a> 3.scroll 经常用于获取滚动距离 scrollTop  scrollLeft</h5><h5 id="_4-注意页面滚动的距离通过-window-pagexoffset-获得" tabindex="-1"><a class="header-anchor" href="#_4-注意页面滚动的距离通过-window-pagexoffset-获得" aria-hidden="true">#</a> 4.注意页面滚动的距离通过 window.pageXOffset  获得</h5><h2 id="_1-5-mouseenter-和mouseover的区别" tabindex="-1"><a class="header-anchor" href="#_1-5-mouseenter-和mouseover的区别" aria-hidden="true">#</a> 1. 5. mouseenter 和mouseover的区别</h2><h5 id="当鼠标移动到元素上时就会触发mouseenter-事件" tabindex="-1"><a class="header-anchor" href="#当鼠标移动到元素上时就会触发mouseenter-事件" aria-hidden="true">#</a> 当鼠标移动到元素上时就会触发mouseenter 事件</h5><h5 id="类似-mouseover-它们两者之间的差别是" tabindex="-1"><a class="header-anchor" href="#类似-mouseover-它们两者之间的差别是" aria-hidden="true">#</a> 类似 mouseover，它们两者之间的差别是</h5><h5 id="mouseover-鼠标经过自身盒子会触发-经过子盒子还会触发。mouseenter-只会经过自身盒子触发" tabindex="-1"><a class="header-anchor" href="#mouseover-鼠标经过自身盒子会触发-经过子盒子还会触发。mouseenter-只会经过自身盒子触发" aria-hidden="true">#</a> mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。mouseenter  只会经过自身盒子触发</h5><h5 id="之所以这样-就是因为mouseenter不会冒泡" tabindex="-1"><a class="header-anchor" href="#之所以这样-就是因为mouseenter不会冒泡" aria-hidden="true">#</a> 之所以这样，就是因为mouseenter不会冒泡</h5><h5 id="跟mouseenter搭配鼠标离开-mouseleave-同样不会冒泡" tabindex="-1"><a class="header-anchor" href="#跟mouseenter搭配鼠标离开-mouseleave-同样不会冒泡" aria-hidden="true">#</a> 跟mouseenter搭配鼠标离开 mouseleave  同样不会冒泡</h5><h2 id="_1-6-动画函数封装" tabindex="-1"><a class="header-anchor" href="#_1-6-动画函数封装" aria-hidden="true">#</a> 1. 6. 动画函数封装</h2><h3 id="_1-6-1-动画实现原理" tabindex="-1"><a class="header-anchor" href="#_1-6-1-动画实现原理" aria-hidden="true">#</a> 1. 6. 1. 动画实现原理</h3><h5 id="核心原理-通过定时器-setinterval-不断移动盒子位置。" tabindex="-1"><a class="header-anchor" href="#核心原理-通过定时器-setinterval-不断移动盒子位置。" aria-hidden="true">#</a> 核心原理：通过定时器 setInterval() 不断移动盒子位置。</h5><h5 id="实现步骤" tabindex="-1"><a class="header-anchor" href="#实现步骤" aria-hidden="true">#</a> 实现步骤：</h5><h5 id="_1-获得盒子当前位置" tabindex="-1"><a class="header-anchor" href="#_1-获得盒子当前位置" aria-hidden="true">#</a> 1. 获得盒子当前位置</h5><h5 id="_2-让盒子在当前位置加上-1-个移动距离" tabindex="-1"><a class="header-anchor" href="#_2-让盒子在当前位置加上-1-个移动距离" aria-hidden="true">#</a> 2. 让盒子在当前位置加上 1 个移动距离</h5><h5 id="_3-利用定时器不断重复这个操作" tabindex="-1"><a class="header-anchor" href="#_3-利用定时器不断重复这个操作" aria-hidden="true">#</a> 3. 利用定时器不断重复这个操作</h5><h5 id="_4-加一个结束定时器的条件" tabindex="-1"><a class="header-anchor" href="#_4-加一个结束定时器的条件" aria-hidden="true">#</a> 4. 加一个结束定时器的条件</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function getScroll() {
return {
left: window.pageXOffset || document.documentElement.scrollLeft ||
document.body.scrollLeft|| 0 ,
top: window.pageYOffset || document.documentElement.scrollTop ||
document.body.scrollTop ||  
    };
 }
使用的时候 getScroll().left
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_5-注意此元素需要添加定位-才能使用element-style-left" tabindex="-1"><a class="header-anchor" href="#_5-注意此元素需要添加定位-才能使用element-style-left" aria-hidden="true">#</a> 5. 注意此元素需要添加定位，才能使用element.style.left</h5><h3 id="_1-6-2-动画函数给不同元素记录不同定时器" tabindex="-1"><a class="header-anchor" href="#_1-6-2-动画函数给不同元素记录不同定时器" aria-hidden="true">#</a> 1. 6. 2. 动画函数给不同元素记录不同定时器</h3><h5 id="如果多个元素都使用这个动画函数-每次都要var-声明定时器。我们可以给不同的元素使用不同的定时器-自己专" tabindex="-1"><a class="header-anchor" href="#如果多个元素都使用这个动画函数-每次都要var-声明定时器。我们可以给不同的元素使用不同的定时器-自己专" aria-hidden="true">#</a> 如果多个元素都使用这个动画函数，每次都要var 声明定时器。我们可以给不同的元素使用不同的定时器（自己专</h5><h5 id="门用自己的定时器-。" tabindex="-1"><a class="header-anchor" href="#门用自己的定时器-。" aria-hidden="true">#</a> 门用自己的定时器）。</h5><h5 id="核心原理-利用-js-是一门动态语言-可以很方便的给当前对象添加属性。" tabindex="-1"><a class="header-anchor" href="#核心原理-利用-js-是一门动态语言-可以很方便的给当前对象添加属性。" aria-hidden="true">#</a> 核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性。</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function animate(obj, target) {
// 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
// 解决方案就是 让我们元素只有一个定时器执行
// 先清除以前的定时器，只保留当前的一个定时器执行
clearInterval(obj.timer);
obj.timer = setInterval(function() {
if (obj.offsetLeft &gt;= target) {
// 停止动画 本质是停止定时器
clearInterval(obj.timer);
                }
obj.style.left = obj.offsetLeft +  1  + &#39;px&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>            },  30 );
        }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,146),s=[n];function h(t,l){return a(),i("div",null,s)}const u=e(r,[["render",h],["__file","05-webapis.html.vue"]]);export{u as default};
