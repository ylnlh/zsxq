import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as i,f as d}from"./app-rpFDZqdF.js";const n={},r=d(`<h1 id="es-6-语法" tabindex="-1"><a class="header-anchor" href="#es-6-语法" aria-hidden="true">#</a> ES 6 语法</h1><h2 id="目标" tabindex="-1"><a class="header-anchor" href="#目标" aria-hidden="true">#</a> 目标</h2><h5 id="能够说出使用let关键字声明变量的特点" tabindex="-1"><a class="header-anchor" href="#能够说出使用let关键字声明变量的特点" aria-hidden="true">#</a> 能够说出使用let关键字声明变量的特点</h5><h5 id="能够使用解构赋值从数组中提取值" tabindex="-1"><a class="header-anchor" href="#能够使用解构赋值从数组中提取值" aria-hidden="true">#</a> 能够使用解构赋值从数组中提取值</h5><h5 id="能够说出箭头函数拥有的特性" tabindex="-1"><a class="header-anchor" href="#能够说出箭头函数拥有的特性" aria-hidden="true">#</a> 能够说出箭头函数拥有的特性</h5><h5 id="能够使用剩余参数接收剩余的函数参数" tabindex="-1"><a class="header-anchor" href="#能够使用剩余参数接收剩余的函数参数" aria-hidden="true">#</a> 能够使用剩余参数接收剩余的函数参数</h5><h5 id="能够使用拓展运算符拆分数组" tabindex="-1"><a class="header-anchor" href="#能够使用拓展运算符拆分数组" aria-hidden="true">#</a> 能够使用拓展运算符拆分数组</h5><h5 id="能够说出模板字符串拥有的特性" tabindex="-1"><a class="header-anchor" href="#能够说出模板字符串拥有的特性" aria-hidden="true">#</a> 能够说出模板字符串拥有的特性</h5><h2 id="es-6-相关概念-★★" tabindex="-1"><a class="header-anchor" href="#es-6-相关概念-★★" aria-hidden="true">#</a> ES 6 相关概念（★★）</h2><h2 id="什么是es-6" tabindex="-1"><a class="header-anchor" href="#什么是es-6" aria-hidden="true">#</a> 什么是ES 6</h2><h5 id="es-的全称是-ecmascript-它是由-ecma-国际标准化组织-制定的一项脚本语言的标准化" tabindex="-1"><a class="header-anchor" href="#es-的全称是-ecmascript-它是由-ecma-国际标准化组织-制定的一项脚本语言的标准化" aria-hidden="true">#</a> ES 的全称是 ECMAScript , 它是由 ECMA 国际标准化组织,制定的一项脚本语言的标准化</h5><h5 id="规范。" tabindex="-1"><a class="header-anchor" href="#规范。" aria-hidden="true">#</a> 规范。</h5><h2 id="为什么使用-es-6" tabindex="-1"><a class="header-anchor" href="#为什么使用-es-6" aria-hidden="true">#</a> 为什么使用 ES 6?</h2><h5 id="每一次标准的诞生都意味着语言的完善-功能的加强。javascript语言本身也有一些令人" tabindex="-1"><a class="header-anchor" href="#每一次标准的诞生都意味着语言的完善-功能的加强。javascript语言本身也有一些令人" aria-hidden="true">#</a> 每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript语言本身也有一些令人</h5><h5 id="不满意的地方。" tabindex="-1"><a class="header-anchor" href="#不满意的地方。" aria-hidden="true">#</a> 不满意的地方。</h5><h5 id="变量提升特性增加了程序运行时的不可预测性" tabindex="-1"><a class="header-anchor" href="#变量提升特性增加了程序运行时的不可预测性" aria-hidden="true">#</a> 变量提升特性增加了程序运行时的不可预测性</h5><h5 id="语法过于松散-实现相同的功能-不同的人可能会写出不同的代码" tabindex="-1"><a class="header-anchor" href="#语法过于松散-实现相同的功能-不同的人可能会写出不同的代码" aria-hidden="true">#</a> 语法过于松散，实现相同的功能，不同的人可能会写出不同的代码</h5><h2 id="es-6-新增语法" tabindex="-1"><a class="header-anchor" href="#es-6-新增语法" aria-hidden="true">#</a> ES 6 新增语法</h2><h2 id="es-6-新增语法-1" tabindex="-1"><a class="header-anchor" href="#es-6-新增语法-1" aria-hidden="true">#</a> ES 6 新增语法</h2><h3 id="let-★★★" tabindex="-1"><a class="header-anchor" href="#let-★★★" aria-hidden="true">#</a> let（★★★）</h3><h5 id="es-6-中新增了用于声明变量的关键字" tabindex="-1"><a class="header-anchor" href="#es-6-中新增了用于声明变量的关键字" aria-hidden="true">#</a> ES 6 中新增了用于声明变量的关键字</h5><h4 id="let声明的变量只在所处于的块级有效" tabindex="-1"><a class="header-anchor" href="#let声明的变量只在所处于的块级有效" aria-hidden="true">#</a> let声明的变量只在所处于的块级有效</h4><h5 id="注意-使用let关键字声明的变量才具有块级作用域-使用var声明的变量不具备块级作用" tabindex="-1"><a class="header-anchor" href="#注意-使用let关键字声明的变量才具有块级作用域-使用var声明的变量不具备块级作用" aria-hidden="true">#</a> 注意：使用let关键字声明的变量才具有块级作用域，使用var声明的变量不具备块级作用</h5><h5 id="域特性。" tabindex="-1"><a class="header-anchor" href="#域特性。" aria-hidden="true">#</a> 域特性。</h5><h4 id="不存在变量提升" tabindex="-1"><a class="header-anchor" href="#不存在变量提升" aria-hidden="true">#</a> 不存在变量提升</h4><h4 id="暂时性死区" tabindex="-1"><a class="header-anchor" href="#暂时性死区" aria-hidden="true">#</a> 暂时性死区</h4><h5 id="利用let声明的变量会绑定在这个块级作用域-不会受外界的影响" tabindex="-1"><a class="header-anchor" href="#利用let声明的变量会绑定在这个块级作用域-不会受外界的影响" aria-hidden="true">#</a> 利用let声明的变量会绑定在这个块级作用域，不会受外界的影响</h5><h4 id="经典面试题" tabindex="-1"><a class="header-anchor" href="#经典面试题" aria-hidden="true">#</a> 经典面试题</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>if (true) {
let a =  10 ;
}
console.log(a) // a is not defined
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>console.log(a); // a is not defined
let a =  20 ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var tmp =  123 ;
if (true) {
tmp = &#39;abc&#39;;
let tmp;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="经典面试题图解-此题的关键点在于变量i是全局的-函数执行时输出的都是全局作用域" tabindex="-1"><a class="header-anchor" href="#经典面试题图解-此题的关键点在于变量i是全局的-函数执行时输出的都是全局作用域" aria-hidden="true">#</a> 经典面试题图解：此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域</h5><h5 id="下的i值。" tabindex="-1"><a class="header-anchor" href="#下的i值。" aria-hidden="true">#</a> 下的i值。</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var arr = [];
for (var i =  0 ; i &lt;  2 ; i++) {
arr[i] = function () {
console.log(i);
}
}
arr[ 0 ]();
arr[ 1 ]();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let arr = [];
for (let i =  0 ; i &lt;  2 ; i++) {
arr[i] = function () {
console.log(i);
}
}
arr[ 0 ]();
arr[ 1 ]();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="经典面试题图解-此题的关键点在于每次循环都会产生一个块级作用域-每个块级作用" tabindex="-1"><a class="header-anchor" href="#经典面试题图解-此题的关键点在于每次循环都会产生一个块级作用域-每个块级作用" aria-hidden="true">#</a> 经典面试题图解：此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用</h5><h5 id="域中的变量都是不同的-函数执行时输出的是自己上一级-循环产生的块级作用域-作" tabindex="-1"><a class="header-anchor" href="#域中的变量都是不同的-函数执行时输出的是自己上一级-循环产生的块级作用域-作" aria-hidden="true">#</a> 域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作</h5><h5 id="用域下的i值" tabindex="-1"><a class="header-anchor" href="#用域下的i值" aria-hidden="true">#</a> 用域下的i值.</h5><h4 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h4><h5 id="let关键字就是用来声明变量的" tabindex="-1"><a class="header-anchor" href="#let关键字就是用来声明变量的" aria-hidden="true">#</a> let关键字就是用来声明变量的</h5><h5 id="使用let关键字声明的变量具有块级作用域" tabindex="-1"><a class="header-anchor" href="#使用let关键字声明的变量具有块级作用域" aria-hidden="true">#</a> 使用let关键字声明的变量具有块级作用域</h5><h5 id="在一个大括号中-使用let关键字声明的变量才具有块级作用域-var关键字是不具备这" tabindex="-1"><a class="header-anchor" href="#在一个大括号中-使用let关键字声明的变量才具有块级作用域-var关键字是不具备这" aria-hidden="true">#</a> 在一个大括号中 使用let关键字声明的变量才具有块级作用域 var关键字是不具备这</h5><h5 id="个特点的" tabindex="-1"><a class="header-anchor" href="#个特点的" aria-hidden="true">#</a> 个特点的</h5><h5 id="防止循环变量变成全局变量" tabindex="-1"><a class="header-anchor" href="#防止循环变量变成全局变量" aria-hidden="true">#</a> 防止循环变量变成全局变量</h5><h5 id="使用let关键字声明的变量没有变量提升" tabindex="-1"><a class="header-anchor" href="#使用let关键字声明的变量没有变量提升" aria-hidden="true">#</a> 使用let关键字声明的变量没有变量提升</h5><h5 id="使用let关键字声明的变量具有暂时性死区特性" tabindex="-1"><a class="header-anchor" href="#使用let关键字声明的变量具有暂时性死区特性" aria-hidden="true">#</a> 使用let关键字声明的变量具有暂时性死区特性</h5><h3 id="const-★★★" tabindex="-1"><a class="header-anchor" href="#const-★★★" aria-hidden="true">#</a> const（★★★）</h3><h5 id="声明常量-常量就是值-内存地址-不能变化的量" tabindex="-1"><a class="header-anchor" href="#声明常量-常量就是值-内存地址-不能变化的量" aria-hidden="true">#</a> 声明常量，常量就是值（内存地址）不能变化的量</h5><h4 id="具有块级作用域" tabindex="-1"><a class="header-anchor" href="#具有块级作用域" aria-hidden="true">#</a> 具有块级作用域</h4><h4 id="声明常量时必须赋值" tabindex="-1"><a class="header-anchor" href="#声明常量时必须赋值" aria-hidden="true">#</a> 声明常量时必须赋值</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>if (true) {
const a =  10 ;
}
console.log(a) // a is not defined
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="常量赋值后-值不能修改" tabindex="-1"><a class="header-anchor" href="#常量赋值后-值不能修改" aria-hidden="true">#</a> 常量赋值后，值不能修改</h4><h4 id="小结-1" tabindex="-1"><a class="header-anchor" href="#小结-1" aria-hidden="true">#</a> 小结</h4><h5 id="const声明的变量是一个常量" tabindex="-1"><a class="header-anchor" href="#const声明的变量是一个常量" aria-hidden="true">#</a> const声明的变量是一个常量</h5><h5 id="既然是常量不能重新进行赋值-如果是基本数据类型-不能更改值-如果是复杂数据" tabindex="-1"><a class="header-anchor" href="#既然是常量不能重新进行赋值-如果是基本数据类型-不能更改值-如果是复杂数据" aria-hidden="true">#</a> 既然是常量不能重新进行赋值，如果是基本数据类型，不能更改值，如果是复杂数据</h5><h5 id="类型-不能更改地址值" tabindex="-1"><a class="header-anchor" href="#类型-不能更改地址值" aria-hidden="true">#</a> 类型，不能更改地址值</h5><h5 id="声明-const时候必须要给定值" tabindex="-1"><a class="header-anchor" href="#声明-const时候必须要给定值" aria-hidden="true">#</a> 声明 const时候必须要给定值</h5><h3 id="let、const、var-的区别" tabindex="-1"><a class="header-anchor" href="#let、const、var-的区别" aria-hidden="true">#</a> let、const、var 的区别</h3><h5 id="使用-var-声明的变量-其作用域为该语句所在的函数内-且存在变量提升现象" tabindex="-1"><a class="header-anchor" href="#使用-var-声明的变量-其作用域为该语句所在的函数内-且存在变量提升现象" aria-hidden="true">#</a> 使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象</h5><h5 id="使用-let-声明的变量-其作用域为该语句所在的代码块内-不存在变量提升" tabindex="-1"><a class="header-anchor" href="#使用-let-声明的变量-其作用域为该语句所在的代码块内-不存在变量提升" aria-hidden="true">#</a> 使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升</h5><h5 id="使用-const-声明的是常量-在后面出现的代码中不能再修改该常量的值" tabindex="-1"><a class="header-anchor" href="#使用-const-声明的是常量-在后面出现的代码中不能再修改该常量的值" aria-hidden="true">#</a> 使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值</h5><h3 id="解构赋值-★★★" tabindex="-1"><a class="header-anchor" href="#解构赋值-★★★" aria-hidden="true">#</a> 解构赋值（★★★）</h3><h5 id="es-6-中允许从数组中提取值-按照对应位置-对变量赋值-对象也可以实现解构" tabindex="-1"><a class="header-anchor" href="#es-6-中允许从数组中提取值-按照对应位置-对变量赋值-对象也可以实现解构" aria-hidden="true">#</a> ES 6 中允许从数组中提取值，按照对应位置，对变量赋值，对象也可以实现解构</h5><h4 id="数组解构" tabindex="-1"><a class="header-anchor" href="#数组解构" aria-hidden="true">#</a> 数组解构</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const PI; // Missing initializer in const declaration
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const PI =  3. 14 ;
PI =  100 ; // Assignment to constant variable.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const ary = [ 100 ,  200 ];
ary[ 0 ] = &#39;a&#39;;
ary[ 1 ] = &#39;b&#39;;
console.log(ary); // [&#39;a&#39;, &#39;b&#39;];
ary = [&#39;a&#39;, &#39;b&#39;]; // Assignment to constant variable.
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="对象解构" tabindex="-1"><a class="header-anchor" href="#对象解构" aria-hidden="true">#</a> 对象解构</h4><h4 id="小结-2" tabindex="-1"><a class="header-anchor" href="#小结-2" aria-hidden="true">#</a> 小结</h4><h5 id="解构赋值就是把数据结构分解-然后给变量进行赋值" tabindex="-1"><a class="header-anchor" href="#解构赋值就是把数据结构分解-然后给变量进行赋值" aria-hidden="true">#</a> 解构赋值就是把数据结构分解，然后给变量进行赋值</h5><h5 id="如果结构不成功-变量跟数值个数不匹配的时候-变量的值为undefined" tabindex="-1"><a class="header-anchor" href="#如果结构不成功-变量跟数值个数不匹配的时候-变量的值为undefined" aria-hidden="true">#</a> 如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined</h5><h5 id="数组解构用中括号包裹-多个变量用逗号隔开-对象解构用花括号包裹-多个变量用" tabindex="-1"><a class="header-anchor" href="#数组解构用中括号包裹-多个变量用逗号隔开-对象解构用花括号包裹-多个变量用" aria-hidden="true">#</a> 数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用</h5><h5 id="逗号隔开" tabindex="-1"><a class="header-anchor" href="#逗号隔开" aria-hidden="true">#</a> 逗号隔开</h5><h5 id="利用解构赋值能够让我们方便的去取对象中的属性跟方法" tabindex="-1"><a class="header-anchor" href="#利用解构赋值能够让我们方便的去取对象中的属性跟方法" aria-hidden="true">#</a> 利用解构赋值能够让我们方便的去取对象中的属性跟方法</h5><h3 id="箭头函数-★★★" tabindex="-1"><a class="header-anchor" href="#箭头函数-★★★" aria-hidden="true">#</a> 箭头函数（★★★）</h3><h5 id="es-6-中新增的定义函数的方式。" tabindex="-1"><a class="header-anchor" href="#es-6-中新增的定义函数的方式。" aria-hidden="true">#</a> ES 6 中新增的定义函数的方式。</h5><h5 id="函数体中只有一句代码-且代码的执行结果就是返回值-可以省略大括号" tabindex="-1"><a class="header-anchor" href="#函数体中只有一句代码-且代码的执行结果就是返回值-可以省略大括号" aria-hidden="true">#</a> 函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let [a, b, c] = [ 1 ,  2 ,  3 ];
console.log(a)// 1
console.log(b)// 2
console.log(c)// 3
//如果解构不成功，变量的值为undefined
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let person = { name: &#39;zhangsan&#39;, age:  20  };
let { name, age } = person;
console.log(name); // &#39;zhangsan&#39;
console.log(age); //  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let {name: myName, age: myAge} = person; // myName myAge 属于别名
console.log(myName); // &#39;zhangsan&#39;
console.log(myAge); //  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="代表是函数-必须要的符号-指向哪一个代码块-函数体" tabindex="-1"><a class="header-anchor" href="#代表是函数-必须要的符号-指向哪一个代码块-函数体" aria-hidden="true">#</a> () =&gt; {} //()：代表是函数； =&gt;：必须要的符号，指向哪一个代码块；{}：函数体</h6><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const fn = () =&gt; {}//代表把一个函数赋值给fn
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h5 id="如果形参只有一个-可以省略小括号" tabindex="-1"><a class="header-anchor" href="#如果形参只有一个-可以省略小括号" aria-hidden="true">#</a> 如果形参只有一个，可以省略小括号</h5><h5 id="箭头函数不绑定this关键字-箭头函数中的this-指向的是函数定义位置的上下文this" tabindex="-1"><a class="header-anchor" href="#箭头函数不绑定this关键字-箭头函数中的this-指向的是函数定义位置的上下文this" aria-hidden="true">#</a> 箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this</h5><h4 id="小结-3" tabindex="-1"><a class="header-anchor" href="#小结-3" aria-hidden="true">#</a> 小结</h4><h5 id="箭头函数中不绑定this-箭头函数中的this指向是它所定义的位置-可以简单理解" tabindex="-1"><a class="header-anchor" href="#箭头函数中不绑定this-箭头函数中的this指向是它所定义的位置-可以简单理解" aria-hidden="true">#</a> 箭头函数中不绑定this，箭头函数中的this指向是它所定义的位置，可以简单理解</h5><h5 id="成-定义箭头函数中的作用域的this指向谁-它就指向谁" tabindex="-1"><a class="header-anchor" href="#成-定义箭头函数中的作用域的this指向谁-它就指向谁" aria-hidden="true">#</a> 成，定义箭头函数中的作用域的this指向谁，它就指向谁</h5><h5 id="箭头函数的优点在于解决了this执行环境所造成的一些问题。比如-解决了匿名函数" tabindex="-1"><a class="header-anchor" href="#箭头函数的优点在于解决了this执行环境所造成的一些问题。比如-解决了匿名函数" aria-hidden="true">#</a> 箭头函数的优点在于解决了this执行环境所造成的一些问题。比如：解决了匿名函数</h5><h5 id="this指向的问题-匿名函数的执行环境具有全局性-包括settimeout和setinterval" tabindex="-1"><a class="header-anchor" href="#this指向的问题-匿名函数的执行环境具有全局性-包括settimeout和setinterval" aria-hidden="true">#</a> this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval</h5><h5 id="中使用this所造成的问题" tabindex="-1"><a class="header-anchor" href="#中使用this所造成的问题" aria-hidden="true">#</a> 中使用this所造成的问题</h5><h4 id="面试题" tabindex="-1"><a class="header-anchor" href="#面试题" aria-hidden="true">#</a> 面试题</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function sum(num 1 , num 2 ) {
return num 1  + num 2 ;
}
//es 6 写法
const sum = (num 1 , num 2 ) =&gt; num 1  + num 2 ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function fn (v) {
return v;
}
//es 6 写法
const fn = v =&gt; v;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const obj = { name: &#39;张三&#39;}
function fn () {
console.log(this);//this 指向 是obj对象
return () =&gt; {
console.log(this);//this 指向 的是箭头函数定义的位置，那么这个箭头函
数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象
}
}
const resFn = fn.call(obj);
resFn();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="剩余参数-★★" tabindex="-1"><a class="header-anchor" href="#剩余参数-★★" aria-hidden="true">#</a> 剩余参数（★★）</h3><h5 id="剩余参数语法允许我们将一个不定数量的参数表示为一个数组-不定参数定义方式-这" tabindex="-1"><a class="header-anchor" href="#剩余参数语法允许我们将一个不定数量的参数表示为一个数组-不定参数定义方式-这" aria-hidden="true">#</a> 剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这</h5><h5 id="种方式很方便的去声明不知道参数情况下的一个函数" tabindex="-1"><a class="header-anchor" href="#种方式很方便的去声明不知道参数情况下的一个函数" aria-hidden="true">#</a> 种方式很方便的去声明不知道参数情况下的一个函数</h5><h4 id="剩余参数和解构配合使用" tabindex="-1"><a class="header-anchor" href="#剩余参数和解构配合使用" aria-hidden="true">#</a> 剩余参数和解构配合使用</h4><h2 id="es-6-的内置对象扩展" tabindex="-1"><a class="header-anchor" href="#es-6-的内置对象扩展" aria-hidden="true">#</a> ES 6 的内置对象扩展</h2><h3 id="array-的扩展方法-★★" tabindex="-1"><a class="header-anchor" href="#array-的扩展方法-★★" aria-hidden="true">#</a> Array 的扩展方法（★★）</h3><h4 id="扩展运算符-展开语法" tabindex="-1"><a class="header-anchor" href="#扩展运算符-展开语法" aria-hidden="true">#</a> 扩展运算符（展开语法）</h4><h5 id="扩展运算符可以将数组或者对象转为用逗号分隔的参数序列" tabindex="-1"><a class="header-anchor" href="#扩展运算符可以将数组或者对象转为用逗号分隔的参数序列" aria-hidden="true">#</a> 扩展运算符可以将数组或者对象转为用逗号分隔的参数序列</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var age =  100 ;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var obj = {
age:  20 ,
say: () =&gt; {
alert(this.age)
}
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>obj.say();//箭头函数this指向的是被声明的作用域里面，而对象没有作用域的，所以箭
头函数虽然在对象中被定义，但是this指向的是全局作用域
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function sum (first, ...args) {
console.log(first); //  
console.log(args); // [ 20 ,  30 ]
}
sum( 10 ,  20 ,  30 )
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let students = [&#39;wangwu&#39;, &#39;zhangsan&#39;, &#39;lisi&#39;];
let [s 1 , ...s 2 ] = students;
console.log(s 1 ); // &#39;wangwu&#39;
console.log(s 2 ); // [&#39;zhangsan&#39;, &#39;lisi&#39;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="扩展运算符可以应用于合并数组" tabindex="-1"><a class="header-anchor" href="#扩展运算符可以应用于合并数组" aria-hidden="true">#</a> 扩展运算符可以应用于合并数组</h5><h5 id="将类数组或可遍历对象转换为真正的数组" tabindex="-1"><a class="header-anchor" href="#将类数组或可遍历对象转换为真正的数组" aria-hidden="true">#</a> 将类数组或可遍历对象转换为真正的数组</h5><h4 id="构造函数方法-array-from" tabindex="-1"><a class="header-anchor" href="#构造函数方法-array-from" aria-hidden="true">#</a> 构造函数方法：Array.from()</h4><h5 id="将伪数组或可遍历对象转换为真正的数组" tabindex="-1"><a class="header-anchor" href="#将伪数组或可遍历对象转换为真正的数组" aria-hidden="true">#</a> 将伪数组或可遍历对象转换为真正的数组</h5><h5 id="方法还可以接受第二个参数-作用类似于数组的map方法-用来对每个元素进行处理" tabindex="-1"><a class="header-anchor" href="#方法还可以接受第二个参数-作用类似于数组的map方法-用来对每个元素进行处理" aria-hidden="true">#</a> 方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，</h5><h5 id="将处理后的值放入返回的数组" tabindex="-1"><a class="header-anchor" href="#将处理后的值放入返回的数组" aria-hidden="true">#</a> 将处理后的值放入返回的数组</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let ary = [ 1 ,  2 ,  3 ];
...ary //  1 ,  2 ,  
console.log(...ary); //  1 2 3 ,相当于下面的代码
console.log( 1 , 2 , 3 );
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="方法一" tabindex="-1"><a class="header-anchor" href="#方法一" aria-hidden="true">#</a> // 方法一</h6><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let ary 1  = [ 1 ,  2 ,  3 ];
let ary 2  = [ 3 ,  4 ,  5 ];
let ary 3  = [...ary 1 , ...ary 2 ];
// 方法二
ary 1 .push(...ary 2 );
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let oDivs = document.getElementsByTagName(&#39;div&#39;);
oDivs = [...oDivs];
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="定义一个集合" tabindex="-1"><a class="header-anchor" href="#定义一个集合" aria-hidden="true">#</a> //定义一个集合</h6><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let arrayLike = {
&#39; 0 &#39;: &#39;a&#39;,
&#39; 1 &#39;: &#39;b&#39;,
&#39; 2 &#39;: &#39;c&#39;,
length:  
};
//转成数组
let arr 2  = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="注意-如果是对象-那么属性需要写对应的索引" tabindex="-1"><a class="header-anchor" href="#注意-如果是对象-那么属性需要写对应的索引" aria-hidden="true">#</a> 注意：如果是对象，那么属性需要写对应的索引</h5><h4 id="实例方法-find" tabindex="-1"><a class="header-anchor" href="#实例方法-find" aria-hidden="true">#</a> 实例方法：find()</h4><h5 id="用于找出第一个符合条件的数组成员-如果没有找到返回undefined" tabindex="-1"><a class="header-anchor" href="#用于找出第一个符合条件的数组成员-如果没有找到返回undefined" aria-hidden="true">#</a> 用于找出第一个符合条件的数组成员，如果没有找到返回undefined</h5><h4 id="实例方法-findindex" tabindex="-1"><a class="header-anchor" href="#实例方法-findindex" aria-hidden="true">#</a> 实例方法：findIndex()</h4><h5 id="用于找出第一个符合条件的数组成员的位置-如果没有找到返回-1" tabindex="-1"><a class="header-anchor" href="#用于找出第一个符合条件的数组成员的位置-如果没有找到返回-1" aria-hidden="true">#</a> 用于找出第一个符合条件的数组成员的位置，如果没有找到返回- 1</h5><h4 id="实例方法-includes" tabindex="-1"><a class="header-anchor" href="#实例方法-includes" aria-hidden="true">#</a> 实例方法：includes()</h4><h5 id="判断某个数组是否包含给定的值-返回布尔值。" tabindex="-1"><a class="header-anchor" href="#判断某个数组是否包含给定的值-返回布尔值。" aria-hidden="true">#</a> 判断某个数组是否包含给定的值，返回布尔值。</h5><h3 id="string-的扩展方法" tabindex="-1"><a class="header-anchor" href="#string-的扩展方法" aria-hidden="true">#</a> String 的扩展方法</h3><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let arrayLike = {
&quot; 0 &quot;:  1 ,
&quot; 1 &quot;:  2 ,
&quot;length&quot;:  
}
let newAry = Array.from(arrayLike, item =&gt; item * 2 )//[ 2 , 4 ]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let ary = [{
id:  1 ,
name: &#39;张三&#39;
}, {
id:  2 ,
name: &#39;李四&#39;
}];
let target = ary.find((item, index) =&gt; item.id ==  2 );//找数组里面符合条件
的值，当数组中元素id等于 2 的查找出来，注意，只会匹配第一个
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let ary = [ 1 ,  5 ,  10 ,  15 ];
let index = ary.findIndex((value, index) =&gt; value &gt;  9 );
console.log(index); //  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>[ 1 ,  2 ,  3 ].includes( 2 ) // true
[ 1 ,  2 ,  3 ].includes( 4 ) // false
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="模板字符串-★★★" tabindex="-1"><a class="header-anchor" href="#模板字符串-★★★" aria-hidden="true">#</a> 模板字符串（★★★）</h4><h5 id="es-6-新增的创建字符串的方式-使用反引号定义" tabindex="-1"><a class="header-anchor" href="#es-6-新增的创建字符串的方式-使用反引号定义" aria-hidden="true">#</a> ES 6 新增的创建字符串的方式，使用反引号定义</h5><h5 id="模板字符串中可以解析变量" tabindex="-1"><a class="header-anchor" href="#模板字符串中可以解析变量" aria-hidden="true">#</a> 模板字符串中可以解析变量</h5><h5 id="模板字符串中可以换行" tabindex="-1"><a class="header-anchor" href="#模板字符串中可以换行" aria-hidden="true">#</a> 模板字符串中可以换行</h5><h5 id="在模板字符串中可以调用函数" tabindex="-1"><a class="header-anchor" href="#在模板字符串中可以调用函数" aria-hidden="true">#</a> 在模板字符串中可以调用函数</h5><h4 id="实例方法-startswith-和-endswith" tabindex="-1"><a class="header-anchor" href="#实例方法-startswith-和-endswith" aria-hidden="true">#</a> 实例方法：startsWith() 和 endsWith()</h4><h5 id="startswith-表示参数字符串是否在原字符串的头部-返回布尔值" tabindex="-1"><a class="header-anchor" href="#startswith-表示参数字符串是否在原字符串的头部-返回布尔值" aria-hidden="true">#</a> startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值</h5><h5 id="endswith-表示参数字符串是否在原字符串的尾部-返回布尔值" tabindex="-1"><a class="header-anchor" href="#endswith-表示参数字符串是否在原字符串的尾部-返回布尔值" aria-hidden="true">#</a> endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let name = \`zhangsan\`;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let name = &#39;张三&#39;;
let sayHello = \`hello,my name is \${name}\`; // hello, my name is zhangsan
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let result = {
name: &#39;zhangsan&#39;,
age:  20 ,
sex: &#39;男&#39;
}
let html = \` &lt;div&gt;
&lt;span&gt;\${result.name}&lt;/span&gt;
&lt;span&gt;\${result.age}&lt;/span&gt;
&lt;span&gt;\${result.sex}&lt;/span&gt;
&lt;/div&gt; \`;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const sayHello = function () {
return &#39;哈哈哈哈 追不到我吧 我就是这么强大&#39;;
};
let greet = \`\${sayHello()} 哈哈哈哈\`;
console.log(greet); // 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="实例方法-repeat" tabindex="-1"><a class="header-anchor" href="#实例方法-repeat" aria-hidden="true">#</a> 实例方法：repeat()</h4><h5 id="repeat方法表示将原字符串重复n次-返回一个新字符串" tabindex="-1"><a class="header-anchor" href="#repeat方法表示将原字符串重复n次-返回一个新字符串" aria-hidden="true">#</a> repeat方法表示将原字符串重复n次，返回一个新字符串</h5><h3 id="set-数据结构-★★" tabindex="-1"><a class="header-anchor" href="#set-数据结构-★★" aria-hidden="true">#</a> Set 数据结构（★★）</h3><h5 id="es-6-提供了新的数据结构-set。它类似于数组-但是成员的值都是唯一的-没有重复的" tabindex="-1"><a class="header-anchor" href="#es-6-提供了新的数据结构-set。它类似于数组-但是成员的值都是唯一的-没有重复的" aria-hidden="true">#</a> ES 6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的</h5><h5 id="值。" tabindex="-1"><a class="header-anchor" href="#值。" aria-hidden="true">#</a> 值。</h5><h5 id="set本身是一个构造函数-用来生成-set-数据结构" tabindex="-1"><a class="header-anchor" href="#set本身是一个构造函数-用来生成-set-数据结构" aria-hidden="true">#</a> Set本身是一个构造函数，用来生成 Set 数据结构</h5><h5 id="set函数可以接受一个数组作为参数-用来初始化。" tabindex="-1"><a class="header-anchor" href="#set函数可以接受一个数组作为参数-用来初始化。" aria-hidden="true">#</a> Set函数可以接受一个数组作为参数，用来初始化。</h5><h4 id="实例方法" tabindex="-1"><a class="header-anchor" href="#实例方法" aria-hidden="true">#</a> 实例方法</h4><h5 id="add-value-添加某个值-返回-set-结构本身" tabindex="-1"><a class="header-anchor" href="#add-value-添加某个值-返回-set-结构本身" aria-hidden="true">#</a> add(value)：添加某个值，返回 Set 结构本身</h5><h5 id="delete-value-删除某个值-返回一个布尔值-表示删除是否成功" tabindex="-1"><a class="header-anchor" href="#delete-value-删除某个值-返回一个布尔值-表示删除是否成功" aria-hidden="true">#</a> delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</h5><h5 id="has-value-返回一个布尔值-表示该值是否为-set-的成员" tabindex="-1"><a class="header-anchor" href="#has-value-返回一个布尔值-表示该值是否为-set-的成员" aria-hidden="true">#</a> has(value)：返回一个布尔值，表示该值是否为 Set 的成员</h5><h5 id="clear-清除所有成员-没有返回值" tabindex="-1"><a class="header-anchor" href="#clear-清除所有成员-没有返回值" aria-hidden="true">#</a> clear()：清除所有成员，没有返回值</h5><h4 id="遍历" tabindex="-1"><a class="header-anchor" href="#遍历" aria-hidden="true">#</a> 遍历</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>let str = &#39;Hello world!&#39;;
str.startsWith(&#39;Hello&#39;) // true
str.endsWith(&#39;!&#39;) // true
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&#39;x&#39;.repeat( 3 ) // &quot;xxx&quot;
&#39;hello&#39;.repeat( 2 ) // &quot;hellohello&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const s = new Set();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const set = new Set([ 1 ,  2 ,  3 ,  4 ,  4 ]);//{ 1 ,  2 ,  3 ,  4 }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>const s = new Set();
s.add( 1 ).add( 2 ).add( 3 ); // 向 set 结构中添加值
s.delete( 2 ) // 删除 set 结构中的 2 值
s.has( 1 ) // 表示 set 结构中是否有 1 这个值 返回布尔值
s.clear() // 清除 set 结构中的所有值
//注意：删除的是元素的值，不是代表的索引
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="set-结构的实例与数组一样-也拥有foreach方法-用于对每个成员执行某种操作-没有" tabindex="-1"><a class="header-anchor" href="#set-结构的实例与数组一样-也拥有foreach方法-用于对每个成员执行某种操作-没有" aria-hidden="true">#</a> Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有</h5><h5 id="返回值。" tabindex="-1"><a class="header-anchor" href="#返回值。" aria-hidden="true">#</a> 返回值。</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>s.forEach(value^ =&gt;^ console.log(value))
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​</p>`,165),s=[r];function t(l,h){return a(),i("div",null,s)}const v=e(n,[["render",t],["__file","05-JavaScript进阶.html.vue"]]);export{v as default};
