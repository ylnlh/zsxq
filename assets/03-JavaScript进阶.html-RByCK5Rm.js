import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as i,f as n}from"./app-hz3rNBT8.js";const d={},s=n(`<h5 id="面向过程-面向对象" tabindex="-1"><a class="header-anchor" href="#面向过程-面向对象" aria-hidden="true">#</a> 面向过程 面向对象</h5><h5 id="优" tabindex="-1"><a class="header-anchor" href="#优" aria-hidden="true">#</a> 优</h5><h5 id="点" tabindex="-1"><a class="header-anchor" href="#点" aria-hidden="true">#</a> 点</h5><h5 id="性能比面向对象高-适合跟" tabindex="-1"><a class="header-anchor" href="#性能比面向对象高-适合跟" aria-hidden="true">#</a> 性能比面向对象高，适合跟</h5><h5 id="硬件联系很紧密的东西-例" tabindex="-1"><a class="header-anchor" href="#硬件联系很紧密的东西-例" aria-hidden="true">#</a> 硬件联系很紧密的东西，例</h5><h5 id="如单片机就采用的面向过程" tabindex="-1"><a class="header-anchor" href="#如单片机就采用的面向过程" aria-hidden="true">#</a> 如单片机就采用的面向过程</h5><h5 id="编程。" tabindex="-1"><a class="header-anchor" href="#编程。" aria-hidden="true">#</a> 编程。</h5><h5 id="易维护、易复用、易扩展-由于面向对象有" tabindex="-1"><a class="header-anchor" href="#易维护、易复用、易扩展-由于面向对象有" aria-hidden="true">#</a> 易维护、易复用、易扩展，由于面向对象有</h5><h5 id="封装、继承、多态性的特性-可以设计出低" tabindex="-1"><a class="header-anchor" href="#封装、继承、多态性的特性-可以设计出低" aria-hidden="true">#</a> 封装、继承、多态性的特性，可以设计出低</h5><h5 id="耦合的系统-使系统-更加灵活、更加易于维" tabindex="-1"><a class="header-anchor" href="#耦合的系统-使系统-更加灵活、更加易于维" aria-hidden="true">#</a> 耦合的系统，使系统 更加灵活、更加易于维</h5><h5 id="护" tabindex="-1"><a class="header-anchor" href="#护" aria-hidden="true">#</a> 护</h5><h5 id="缺" tabindex="-1"><a class="header-anchor" href="#缺" aria-hidden="true">#</a> 缺</h5><h5 id="点-1" tabindex="-1"><a class="header-anchor" href="#点-1" aria-hidden="true">#</a> 点</h5><h5 id="不易维护、不易复用、不易" tabindex="-1"><a class="header-anchor" href="#不易维护、不易复用、不易" aria-hidden="true">#</a> 不易维护、不易复用、不易</h5><h5 id="扩展" tabindex="-1"><a class="header-anchor" href="#扩展" aria-hidden="true">#</a> 扩展</h5><h5 id="性能比面向过程低" tabindex="-1"><a class="header-anchor" href="#性能比面向过程低" aria-hidden="true">#</a> 性能比面向过程低</h5><h1 id="javascript高级第-01-天笔记" tabindex="-1"><a class="header-anchor" href="#javascript高级第-01-天笔记" aria-hidden="true">#</a> JavaScript高级第 01 天笔记</h1><h2 id="_1-面向过程与面向对象" tabindex="-1"><a class="header-anchor" href="#_1-面向过程与面向对象" aria-hidden="true">#</a> 1 .面向过程与面向对象</h2><h2 id="_1-1-面向过程" tabindex="-1"><a class="header-anchor" href="#_1-1-面向过程" aria-hidden="true">#</a> 1. 1 面向过程</h2><h5 id="面向过程就是分析出解决问题所需要的步骤-然后用函数把这些步骤一步一步实现" tabindex="-1"><a class="header-anchor" href="#面向过程就是分析出解决问题所需要的步骤-然后用函数把这些步骤一步一步实现" aria-hidden="true">#</a> 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，</h5><h5 id="使用的时候再一个一个的依次调用就可以了。" tabindex="-1"><a class="header-anchor" href="#使用的时候再一个一个的依次调用就可以了。" aria-hidden="true">#</a> 使用的时候再一个一个的依次调用就可以了。</h5><h2 id="_1-2-面向对象" tabindex="-1"><a class="header-anchor" href="#_1-2-面向对象" aria-hidden="true">#</a> 1. 2 面向对象</h2><h5 id="面向对象是把事务分解成为一个个对象-然后由对象之间分工与合作。" tabindex="-1"><a class="header-anchor" href="#面向对象是把事务分解成为一个个对象-然后由对象之间分工与合作。" aria-hidden="true">#</a> 面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。</h5><h2 id="_1-3-面向过程与面向对象对比" tabindex="-1"><a class="header-anchor" href="#_1-3-面向过程与面向对象对比" aria-hidden="true">#</a> 1. 3 面向过程与面向对象对比</h2><h2 id="_2-对象与类" tabindex="-1"><a class="header-anchor" href="#_2-对象与类" aria-hidden="true">#</a> 2 .对象与类</h2><h2 id="_2-1-对象" tabindex="-1"><a class="header-anchor" href="#_2-1-对象" aria-hidden="true">#</a> 2. 1 对象</h2><h5 id="对象是由属性和方法组成的-是一个无序键值对的集合-指的是一个具体的事物" tabindex="-1"><a class="header-anchor" href="#对象是由属性和方法组成的-是一个无序键值对的集合-指的是一个具体的事物" aria-hidden="true">#</a> 对象是由属性和方法组成的：是一个无序键值对的集合,指的是一个具体的事物</h5><h5 id="属性-事物的特征-在对象中用属性来表示-常用名词" tabindex="-1"><a class="header-anchor" href="#属性-事物的特征-在对象中用属性来表示-常用名词" aria-hidden="true">#</a> 属性：事物的特征，在对象中用属性来表示（常用名词）</h5><h5 id="方法-事物的行为-在对象中用方法来表示-常用动词" tabindex="-1"><a class="header-anchor" href="#方法-事物的行为-在对象中用方法来表示-常用动词" aria-hidden="true">#</a> 方法：事物的行为，在对象中用方法来表示（常用动词）</h5><h4 id="_2-1-1-创建对象" tabindex="-1"><a class="header-anchor" href="#_2-1-1-创建对象" aria-hidden="true">#</a> 2. 1. 1 创建对象</h4><h5 id="如上两行代码运行结果为" tabindex="-1"><a class="header-anchor" href="#如上两行代码运行结果为" aria-hidden="true">#</a> 如上两行代码运行结果为:</h5><h3 id="_2-2-类" tabindex="-1"><a class="header-anchor" href="#_2-2-类" aria-hidden="true">#</a> 2. 2 类</h3><h5 id="在-es-6-中新增加了类的概念-可以使用-class-关键字声明一个类-之后以这个类来实" tabindex="-1"><a class="header-anchor" href="#在-es-6-中新增加了类的概念-可以使用-class-关键字声明一个类-之后以这个类来实" aria-hidden="true">#</a> 在 ES 6 中新增加了类的概念，可以使用 class 关键字声明一个类，之后以这个类来实</h5><h5 id="例化对象。类抽象了对象的公共部分-它泛指某一大类-class-对象特指某一个" tabindex="-1"><a class="header-anchor" href="#例化对象。类抽象了对象的公共部分-它泛指某一大类-class-对象特指某一个" aria-hidden="true">#</a> 例化对象。类抽象了对象的公共部分，它泛指某一大类（class）对象特指某一个，</h5><h5 id="通过类实例化一个具体的对象" tabindex="-1"><a class="header-anchor" href="#通过类实例化一个具体的对象" aria-hidden="true">#</a> 通过类实例化一个具体的对象</h5><h4 id="_2-2-1-创建类" tabindex="-1"><a class="header-anchor" href="#_2-2-1-创建类" aria-hidden="true">#</a> 2. 2. 1 创建类</h4><h5 id="_1-语法" tabindex="-1"><a class="header-anchor" href="#_1-语法" aria-hidden="true">#</a> 1. 语法:</h5><h5 id="_1-示例" tabindex="-1"><a class="header-anchor" href="#_1-示例" aria-hidden="true">#</a> 1. 示例</h5><h6 id="以下代码是对对象的复习" tabindex="-1"><a class="header-anchor" href="#以下代码是对对象的复习" aria-hidden="true">#</a> //以下代码是对对象的复习</h6><h6 id="字面量创建对象" tabindex="-1"><a class="header-anchor" href="#字面量创建对象" aria-hidden="true">#</a> //字面量创建对象</h6><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var ldh = {
name: &#39;刘德华&#39;,
age:  
}
console.log(ldh);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//构造函数创建对象
function Star(name, age) {
this.name = name;
this.age = age;
}
var ldh = new Star(&#39;刘德华&#39;,  18 )//实例化对象
console.log(ldh);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//步骤 1  使用class关键字
class name {
// class body
}
//步骤 2 使用定义的类创建实例 注意new关键字
var xx = new name();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="以上代码运行结果" tabindex="-1"><a class="header-anchor" href="#以上代码运行结果" aria-hidden="true">#</a> 以上代码运行结果:</h5><h5 id="通过结果我们可以看出-运行结果和使用构造函数方式一样" tabindex="-1"><a class="header-anchor" href="#通过结果我们可以看出-运行结果和使用构造函数方式一样" aria-hidden="true">#</a> 通过结果我们可以看出,运行结果和使用构造函数方式一样</h5><h4 id="_2-2-2-类创建添加属性和方法" tabindex="-1"><a class="header-anchor" href="#_2-2-2-类创建添加属性和方法" aria-hidden="true">#</a> 2. 2. 2 类创建添加属性和方法</h4><h5 id="以上代码运行结果-1" tabindex="-1"><a class="header-anchor" href="#以上代码运行结果-1" aria-hidden="true">#</a> 以上代码运行结果:</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//  1. 创建类 class 创建一个 明星类
class Star {
// 类的共有属性放到 constructor 里面
constructor(name, age) {
this.name = name;
this.age = age;
}
}
//  2. 利用类创建对象 new
var ldh = new Star(&#39;刘德华&#39;,  18 );
console.log(ldh);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>//  1. 创建类 class 创建一个类
class Star {
// 类的共有属性放到 constructor 里面 constructor是 构造器或者构造函数
constructor(uname, age) {
this.uname = uname;
this.age = age;
}//‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐‐&gt;注意,方法与方法之间不需
要添加逗号
sing(song) {
console.log(this.uname + &#39;唱&#39; + song);
}
}
//  2. 利用类创建对象 new
var ldh = new Star(&#39;刘德华&#39;,  18 );
console.log(ldh); // Star {uname: &quot;刘德华&quot;, age:  18 }
ldh.sing(&#39;冰雨&#39;); // 刘德华唱冰雨
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="注意哟" tabindex="-1"><a class="header-anchor" href="#注意哟" aria-hidden="true">#</a> 注意哟:</h5><h5 id="_1-通过class-关键字创建类-类名我们还是习惯性定义首字母大写" tabindex="-1"><a class="header-anchor" href="#_1-通过class-关键字创建类-类名我们还是习惯性定义首字母大写" aria-hidden="true">#</a> 1. 通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</h5><h5 id="_2-类里面有个constructor-函数-可以接受传递过来的参数-同时返回实例对象" tabindex="-1"><a class="header-anchor" href="#_2-类里面有个constructor-函数-可以接受传递过来的参数-同时返回实例对象" aria-hidden="true">#</a> 2. 类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象</h5><h5 id="_3-constructor-函数-只要-new-生成实例时-就会自动调用这个函数-如果我们不写这个" tabindex="-1"><a class="header-anchor" href="#_3-constructor-函数-只要-new-生成实例时-就会自动调用这个函数-如果我们不写这个" aria-hidden="true">#</a> 3. constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个</h5><h5 id="函数-类也会自动生成这个函数" tabindex="-1"><a class="header-anchor" href="#函数-类也会自动生成这个函数" aria-hidden="true">#</a> 函数,类也会自动生成这个函数</h5><h5 id="_4-多个函数方法之间不需要添加逗号分隔" tabindex="-1"><a class="header-anchor" href="#_4-多个函数方法之间不需要添加逗号分隔" aria-hidden="true">#</a> 4. 多个函数方法之间不需要添加逗号分隔</h5><h5 id="_5-生成实例-new-不能省略" tabindex="-1"><a class="header-anchor" href="#_5-生成实例-new-不能省略" aria-hidden="true">#</a> 5. 生成实例 new 不能省略</h5><h5 id="_6-语法规范-创建类-类名后面不要加小括号-生成实例-类名后面加小括号-构造函数不需" tabindex="-1"><a class="header-anchor" href="#_6-语法规范-创建类-类名后面不要加小括号-生成实例-类名后面加小括号-构造函数不需" aria-hidden="true">#</a> 6. 语法规范, 创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需</h5><h5 id="要加function" tabindex="-1"><a class="header-anchor" href="#要加function" aria-hidden="true">#</a> 要加function</h5><h4 id="_2-2-3-类的继承" tabindex="-1"><a class="header-anchor" href="#_2-2-3-类的继承" aria-hidden="true">#</a> 2. 2. 3 类的继承</h4><h5 id="_1-语法-1" tabindex="-1"><a class="header-anchor" href="#_1-语法-1" aria-hidden="true">#</a> 1. 语法</h5><h5 id="_1-示例-1" tabindex="-1"><a class="header-anchor" href="#_1-示例-1" aria-hidden="true">#</a> 1. 示例</h5><h6 id="父类" tabindex="-1"><a class="header-anchor" href="#父类" aria-hidden="true">#</a> // 父类</h6><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>class Father{
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>// 子类继承父类
class Son extends Father {
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="以上代码运行结果-2" tabindex="-1"><a class="header-anchor" href="#以上代码运行结果-2" aria-hidden="true">#</a> 以上代码运行结果:</h5><h5 id="子类使用super关键字访问父类的方法" tabindex="-1"><a class="header-anchor" href="#子类使用super关键字访问父类的方法" aria-hidden="true">#</a> 子类使用super关键字访问父类的方法</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>class Father {
constructor(surname) {
this.surname= surname;
}
say() {
console.log(&#39;你的姓是&#39; + this.surname);
}
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>class Son extends Father{ // 这样子类就继承了父类的属性和方法
}
var damao= new Son(&#39;刘&#39;);
damao.say(); //结果为 你的姓是刘
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="定义了父类" tabindex="-1"><a class="header-anchor" href="#定义了父类" aria-hidden="true">#</a> //定义了父类</h6><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>class Father {
constructor(x, y) {
this.x = x;
this.y = y;
}
sum() {
console.log(this.x + this.y);
}
}
//子元素继承父类
class Son extends Father {
constructor(x, y) {
super(x, y); //使用super调用了父类中的构造函数
}
}
var son = new Son( 1 ,  2 );
son.sum(); //结果为 3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="注意" tabindex="-1"><a class="header-anchor" href="#注意" aria-hidden="true">#</a> 注意:</h5><h5 id="_1-继承中-如果实例化子类输出一个方法-先看子类有没有这个方法-如果有就先执行" tabindex="-1"><a class="header-anchor" href="#_1-继承中-如果实例化子类输出一个方法-先看子类有没有这个方法-如果有就先执行" aria-hidden="true">#</a> 1. 继承中,如果实例化子类输出一个方法,先看子类有没有这个方法,如果有就先执行</h5><h5 id="子类的" tabindex="-1"><a class="header-anchor" href="#子类的" aria-hidden="true">#</a> 子类的</h5><h5 id="_2-继承中-如果子类里面没有-就去查找父类有没有这个方法-如果有-就执行父类的这" tabindex="-1"><a class="header-anchor" href="#_2-继承中-如果子类里面没有-就去查找父类有没有这个方法-如果有-就执行父类的这" aria-hidden="true">#</a> 2. 继承中,如果子类里面没有,就去查找父类有没有这个方法,如果有,就执行父类的这</h5><h5 id="个方法-就近原则" tabindex="-1"><a class="header-anchor" href="#个方法-就近原则" aria-hidden="true">#</a> 个方法(就近原则)</h5><h5 id="_3-如果子类想要继承父类的方法-同时在自己内部扩展自己的方法-利用super-调用" tabindex="-1"><a class="header-anchor" href="#_3-如果子类想要继承父类的方法-同时在自己内部扩展自己的方法-利用super-调用" aria-hidden="true">#</a> 3. 如果子类想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用</h5><h5 id="父类的构造函数-super-必须在子类this之前调用" tabindex="-1"><a class="header-anchor" href="#父类的构造函数-super-必须在子类this之前调用" aria-hidden="true">#</a> 父类的构造函数,super 必须在子类this之前调用</h5><h5 id="以上代码运行结果为" tabindex="-1"><a class="header-anchor" href="#以上代码运行结果为" aria-hidden="true">#</a> 以上代码运行结果为:</h5><h6 id="父类有加法方法" tabindex="-1"><a class="header-anchor" href="#父类有加法方法" aria-hidden="true">#</a> // 父类有加法方法</h6><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>class Father {
constructor(x, y) {
this.x = x;
this.y = y;
}
sum() {
console.log(this.x + this.y);
}
}
// 子类继承父类加法方法 同时 扩展减法方法
class Son extends Father {
constructor(x, y) {
// 利用super 调用父类的构造函数 super 必须在子类this之前调用,放到
this之后会报错
super(x, y);
this.x = x;
this.y = y;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>}
subtract() {
console.log(this.x ‐ this.y);
}
}
var son = new Son( 5 ,  3 );
son.subtract(); // 2
son.sum();// 8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_4-时刻注意this的指向问题-类里面的共有的属性和方法一定要加this使用" tabindex="-1"><a class="header-anchor" href="#_4-时刻注意this的指向问题-类里面的共有的属性和方法一定要加this使用" aria-hidden="true">#</a> 4. 时刻注意this的指向问题,类里面的共有的属性和方法一定要加this使用.</h5><h5 id="_1-constructor中的this指向的是new出来的实例对象" tabindex="-1"><a class="header-anchor" href="#_1-constructor中的this指向的是new出来的实例对象" aria-hidden="true">#</a> 1. constructor中的this指向的是new出来的实例对象</h5><h5 id="_2-自定义的方法-一般也指向的new出来的实例对象" tabindex="-1"><a class="header-anchor" href="#_2-自定义的方法-一般也指向的new出来的实例对象" aria-hidden="true">#</a> 2. 自定义的方法,一般也指向的new出来的实例对象</h5><h5 id="_3-绑定事件之后this指向的就是触发事件的事件源" tabindex="-1"><a class="header-anchor" href="#_3-绑定事件之后this指向的就是触发事件的事件源" aria-hidden="true">#</a> 3. 绑定事件之后this指向的就是触发事件的事件源</h5><h5 id="_5-在-es-6-中类没有变量提升-所以必须先定义类-才能通过类实例化对象" tabindex="-1"><a class="header-anchor" href="#_5-在-es-6-中类没有变量提升-所以必须先定义类-才能通过类实例化对象" aria-hidden="true">#</a> 5. 在 ES 6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象</h5><h2 id="_3-面向对象版tab-栏切换" tabindex="-1"><a class="header-anchor" href="#_3-面向对象版tab-栏切换" aria-hidden="true">#</a> 3 .面向对象版tab 栏切换</h2><h3 id="_3-1-功能需求" tabindex="-1"><a class="header-anchor" href="#_3-1-功能需求" aria-hidden="true">#</a> 3. 1 功能需求</h3><h5 id="_1-点击-tab栏-可以切换效果" tabindex="-1"><a class="header-anchor" href="#_1-点击-tab栏-可以切换效果" aria-hidden="true">#</a> 1. 点击 tab栏,可以切换效果.</h5><h5 id="_2-点击-号-可以添加-tab-项和内容项" tabindex="-1"><a class="header-anchor" href="#_2-点击-号-可以添加-tab-项和内容项" aria-hidden="true">#</a> 2. 点击 + 号, 可以添加 tab 项和内容项.</h5><h5 id="_3-点击-x-号-可以删除当前的tab项和内容项" tabindex="-1"><a class="header-anchor" href="#_3-点击-x-号-可以删除当前的tab项和内容项" aria-hidden="true">#</a> 3. 点击 x 号, 可以删除当前的tab项和内容项.</h5><h5 id="_4-双击tab项文字或者内容项文字可以修改里面的文字内容" tabindex="-1"><a class="header-anchor" href="#_4-双击tab项文字或者内容项文字可以修改里面的文字内容" aria-hidden="true">#</a> 4. 双击tab项文字或者内容项文字可以修改里面的文字内容</h5><h3 id="_3-2-案例准备" tabindex="-1"><a class="header-anchor" href="#_3-2-案例准备" aria-hidden="true">#</a> 3. 2 案例准备</h3><h5 id="_1-获取到标题元素" tabindex="-1"><a class="header-anchor" href="#_1-获取到标题元素" aria-hidden="true">#</a> 1. 获取到标题元素</h5><h5 id="_2-获取到内容元素" tabindex="-1"><a class="header-anchor" href="#_2-获取到内容元素" aria-hidden="true">#</a> 2. 获取到内容元素</h5><h5 id="_3-获取到删除的小按钮-x号" tabindex="-1"><a class="header-anchor" href="#_3-获取到删除的小按钮-x号" aria-hidden="true">#</a> 3. 获取到删除的小按钮 x号</h5><h5 id="_4-新建js文件-定义类-添加需要的属性方法-切换-删除-增加-修改" tabindex="-1"><a class="header-anchor" href="#_4-新建js文件-定义类-添加需要的属性方法-切换-删除-增加-修改" aria-hidden="true">#</a> 4. 新建js文件,定义类,添加需要的属性方法(切换,删除,增加,修改)</h5><h5 id="_5-时刻注意this的指向问题" tabindex="-1"><a class="header-anchor" href="#_5-时刻注意this的指向问题" aria-hidden="true">#</a> 5. 时刻注意this的指向问题</h5><h3 id="_3-3-切换" tabindex="-1"><a class="header-anchor" href="#_3-3-切换" aria-hidden="true">#</a> 3. 3 切换</h3><h5 id="为获取到的标题绑定点击事件-展示对应的内容区域-存储对应的索引" tabindex="-1"><a class="header-anchor" href="#为获取到的标题绑定点击事件-展示对应的内容区域-存储对应的索引" aria-hidden="true">#</a> 为获取到的标题绑定点击事件,展示对应的内容区域,存储对应的索引</h5><h5 id="使用排他-实现只有一个元素的显示" tabindex="-1"><a class="header-anchor" href="#使用排他-实现只有一个元素的显示" aria-hidden="true">#</a> 使用排他,实现只有一个元素的显示</h5><h3 id="_3-4-添加" tabindex="-1"><a class="header-anchor" href="#_3-4-添加" aria-hidden="true">#</a> 3. 4 添加</h3><h5 id="为添加按钮-绑定点击事件" tabindex="-1"><a class="header-anchor" href="#为添加按钮-绑定点击事件" aria-hidden="true">#</a> 为添加按钮+ 绑定点击事件</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>this.lis[i].index = i;
this.lis[i].onclick = this.toggleTab;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>toggleTab() {
//将所有的标题与内容类样式全部移除
for (var i =  0 ; i &lt; this.lis.length; i++) {
this.lis[i].className = &#39;&#39;;
this.sections[i].className = &#39;&#39;;
}
//为当前的标题添加激活样式
this.className = &#39;liactive&#39;;
//为当前的内容添加激活样式
that.sections[this.index].className = &#39;conactive&#39;;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="实现标题与内容的添加-做好排他处理" tabindex="-1"><a class="header-anchor" href="#实现标题与内容的添加-做好排他处理" aria-hidden="true">#</a> 实现标题与内容的添加,做好排他处理</h5><h3 id="_3-5-删除" tabindex="-1"><a class="header-anchor" href="#_3-5-删除" aria-hidden="true">#</a> 3. 5 删除</h3><h5 id="为元素的删除按钮x绑定点击事件" tabindex="-1"><a class="header-anchor" href="#为元素的删除按钮x绑定点击事件" aria-hidden="true">#</a> 为元素的删除按钮x绑定点击事件</h5><h5 id="获取到点击的删除按钮的所在的父元素的所有-删除对应的标题与内容" tabindex="-1"><a class="header-anchor" href="#获取到点击的删除按钮的所在的父元素的所有-删除对应的标题与内容" aria-hidden="true">#</a> 获取到点击的删除按钮的所在的父元素的所有,删除对应的标题与内容</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>this.add.onclick = this.addTab;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>addTab() {
that.clearClass();
// ( 1 ) 创建li元素和section元素
var random = Math.random();
var li = &#39;&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span
class=&quot;iconfont icon‐guanbi&quot;&gt; &lt;/span&gt;&lt;/li&gt;&#39;;
var section = &#39;&lt;section class=&quot;conactive&quot;&gt;测试 &#39; + random +
&#39;&lt;/section&gt;&#39;;
// ( 2 ) 把这两个元素追加到对应的父元素里面
that.ul.insertAdjacentHTML(&#39;beforeend&#39;, li);
that.fsection.insertAdjacentHTML(&#39;beforeend&#39;, section);
that.init();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>this.remove[i].onclick = this.removeTab;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_3-6-编辑" tabindex="-1"><a class="header-anchor" href="#_3-6-编辑" aria-hidden="true">#</a> 3. 6 编辑</h3><h5 id="为元素-标题与内容-绑定双击事件" tabindex="-1"><a class="header-anchor" href="#为元素-标题与内容-绑定双击事件" aria-hidden="true">#</a> 为元素(标题与内容)绑定双击事件</h5><h5 id="在双击事件处理文本选中状态-修改内部dom节点-实现新旧value值的传递" tabindex="-1"><a class="header-anchor" href="#在双击事件处理文本选中状态-修改内部dom节点-实现新旧value值的传递" aria-hidden="true">#</a> 在双击事件处理文本选中状态,修改内部DOM节点,实现新旧value值的传递</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>removeTab(e) {
e.stopPropagation(); // 阻止冒泡 防止触发li 的切换点击事件
var index = this.parentNode.index;
console.log(index);
// 根据索引号删除对应的li 和section remove()方法可以直接删除指定的
元素
that.lis[index].remove();
that.sections[index].remove();
that.init();
// 当我们删除的不是选中状态的li 的时候,原来的选中状态li保持不变
if (document.querySelector(&#39;.liactive&#39;)) return;
// 当我们删除了选中状态的这个li 的时候, 让它的前一个li 处于选定状态
index‐‐;
// 手动调用我们的点击事件 不需要鼠标触发
that.lis[index] &amp;&amp; that.lis[index].click();
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>this.spans[i].ondblclick = this.editTab;
this.sections[i].ondblclick = this.editTab;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>editTab()^ { var str = this.innerHTML; // 双击禁止选定文字 window.getSelection? window.getSelection().removeAllRanges() : document.selection.empty(); // alert( 11 ); this.innerHTML = &#39;<input type="text">&#39;; var input = this.children[ 0 ]; input.value = str; input.select(); // 文本框里面的文字处于选定状态 // 当我们离开文本框就把文本框里面的值给span input.onblur = function() { this.parentNode.innerHTML = this.value; }; // 按下回车也可以把文本框里面的值给span input.onkeyup = function(e) { if (e.keyCode ===  13 ) { // 手动调用表单失去焦点事件 不需要鼠标离开操作 this.blur(); } } }</p><p>​</p>`,119),r=[s];function h(l,t){return a(),i("div",null,r)}const v=e(d,[["render",h],["__file","03-JavaScript进阶.html.vue"]]);export{v as default};
