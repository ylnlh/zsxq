import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as i,f as n}from"./app-hz3rNBT8.js";const d={},r=n(`<p>​</p><h1 id="day06-web-apis" tabindex="-1"><a class="header-anchor" href="#day06-web-apis" aria-hidden="true">#</a> day06 - Web APIs</h1><h4 id="学习目标" tabindex="-1"><a class="header-anchor" href="#学习目标" aria-hidden="true">#</a> 学习目标:</h4><h4 id="能够封装简单动画函数" tabindex="-1"><a class="header-anchor" href="#能够封装简单动画函数" aria-hidden="true">#</a> 能够封装简单动画函数</h4><h4 id="能够理解缓动动画的封装" tabindex="-1"><a class="header-anchor" href="#能够理解缓动动画的封装" aria-hidden="true">#</a> 能够理解缓动动画的封装</h4><h4 id="能够使用动画函数" tabindex="-1"><a class="header-anchor" href="#能够使用动画函数" aria-hidden="true">#</a> 能够使用动画函数</h4><h4 id="能够写出网页轮播图案例" tabindex="-1"><a class="header-anchor" href="#能够写出网页轮播图案例" aria-hidden="true">#</a> 能够写出网页轮播图案例</h4><h4 id="能够写出移动端触屏事件" tabindex="-1"><a class="header-anchor" href="#能够写出移动端触屏事件" aria-hidden="true">#</a> 能够写出移动端触屏事件</h4><h2 id="_1-1-动画函数封装" tabindex="-1"><a class="header-anchor" href="#_1-1-动画函数封装" aria-hidden="true">#</a> 1.1. 动画函数封装</h2><h2 id="_1-1-1-缓动效果原理" tabindex="-1"><a class="header-anchor" href="#_1-1-1-缓动效果原理" aria-hidden="true">#</a> 1.1.1 缓动效果原理</h2><h4 id="缓动动画就是让元素运动速度有所变化-最常见的是让速度慢慢停下来" tabindex="-1"><a class="header-anchor" href="#缓动动画就是让元素运动速度有所变化-最常见的是让速度慢慢停下来" aria-hidden="true">#</a> 缓动动画就是让元素运动速度有所变化，最常见的是让速度慢慢停下来</h4><h4 id="思路" tabindex="-1"><a class="header-anchor" href="#思路" aria-hidden="true">#</a> 思路：</h4><h4 id="_1-让盒子每次移动的距离慢慢变小-速度就会慢慢落下来。" tabindex="-1"><a class="header-anchor" href="#_1-让盒子每次移动的距离慢慢变小-速度就会慢慢落下来。" aria-hidden="true">#</a> 1. 让盒子每次移动的距离慢慢变小，速度就会慢慢落下来。</h4><h4 id="_2-核心算法-目标值-现在的位置-10-做为每次移动的距离步长" tabindex="-1"><a class="header-anchor" href="#_2-核心算法-目标值-现在的位置-10-做为每次移动的距离步长" aria-hidden="true">#</a> 2. 核心算法： (目标值 - 现在的位置)   /  10    做为每次移动的距离步长</h4><h4 id="_3-停止的条件是-让当前盒子位置等于目标位置就停止定时器" tabindex="-1"><a class="header-anchor" href="#_3-停止的条件是-让当前盒子位置等于目标位置就停止定时器" aria-hidden="true">#</a> 3. 停止的条件是： 让当前盒子位置等于目标位置就停止定时器</h4><h4 id="_4-注意步长值需要取整" tabindex="-1"><a class="header-anchor" href="#_4-注意步长值需要取整" aria-hidden="true">#</a> 4. 注意步长值需要取整</h4><h2 id="_1-1-2-动画函数多个目标值之间移动" tabindex="-1"><a class="header-anchor" href="#_1-1-2-动画函数多个目标值之间移动" aria-hidden="true">#</a> 1.1.2 动画函数多个目标值之间移动</h2><h4 id="可以让动画函数从-800-移动到-500-。" tabindex="-1"><a class="header-anchor" href="#可以让动画函数从-800-移动到-500-。" aria-hidden="true">#</a> 可以让动画函数从 800 移动到 500 。</h4><h4 id="当我们点击按钮时候-判断步长是正值还是负值" tabindex="-1"><a class="header-anchor" href="#当我们点击按钮时候-判断步长是正值还是负值" aria-hidden="true">#</a> 当我们点击按钮时候，判断步长是正值还是负值</h4><h4 id="_1-如果是正值-则步长往大了取整" tabindex="-1"><a class="header-anchor" href="#_1-如果是正值-则步长往大了取整" aria-hidden="true">#</a> 1.如果是正值，则步长往大了取整</h4><h4 id="_2-如果是负值-则步长-向小了取整" tabindex="-1"><a class="header-anchor" href="#_2-如果是负值-则步长-向小了取整" aria-hidden="true">#</a> 2.如果是负值，则步长 向小了取整</h4><h2 id="_1-1-3-动函数添加回调函数" tabindex="-1"><a class="header-anchor" href="#_1-1-3-动函数添加回调函数" aria-hidden="true">#</a> 1.1.3 动函数添加回调函数</h2><h4 id="回调函数原理-函数可以作为一个参数。将这个函数作为参数传到另一个函数里面-当那个函数执行完之后-再执" tabindex="-1"><a class="header-anchor" href="#回调函数原理-函数可以作为一个参数。将这个函数作为参数传到另一个函数里面-当那个函数执行完之后-再执" aria-hidden="true">#</a> 回调函数原理：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执</h4><h4 id="行传进去的这个函数-这个过程就叫做回调。" tabindex="-1"><a class="header-anchor" href="#行传进去的这个函数-这个过程就叫做回调。" aria-hidden="true">#</a> 行传进去的这个函数，这个过程就叫做回调。</h4><h4 id="回调函数写的位置-定时器结束的位置。" tabindex="-1"><a class="header-anchor" href="#回调函数写的位置-定时器结束的位置。" aria-hidden="true">#</a> 回调函数写的位置：定时器结束的位置。</h4><h2 id="_1-1-4-动画完整版代码" tabindex="-1"><a class="header-anchor" href="#_1-1-4-动画完整版代码" aria-hidden="true">#</a> 1.1.4 动画完整版代码:</h2><h2 id="_1-2-常见网页特效案例" tabindex="-1"><a class="header-anchor" href="#_1-2-常见网页特效案例" aria-hidden="true">#</a> 1.2. 常见网页特效案例</h2><h3 id="_1-2-1-案例-网页轮播图" tabindex="-1"><a class="header-anchor" href="#_1-2-1-案例-网页轮播图" aria-hidden="true">#</a> 1.2.1 案例：网页轮播图</h3><h4 id="轮播图也称为焦点图-是网页中比较常见的网页特效。" tabindex="-1"><a class="header-anchor" href="#轮播图也称为焦点图-是网页中比较常见的网页特效。" aria-hidden="true">#</a> 轮播图也称为焦点图，是网页中比较常见的网页特效。</h4><h4 id="功能需求" tabindex="-1"><a class="header-anchor" href="#功能需求" aria-hidden="true">#</a> 功能需求：</h4><h4 id="_1-鼠标经过轮播图模块-左右按钮显示-离开隐藏左右按钮。" tabindex="-1"><a class="header-anchor" href="#_1-鼠标经过轮播图模块-左右按钮显示-离开隐藏左右按钮。" aria-hidden="true">#</a> 1.鼠标经过轮播图模块，左右按钮显示，离开隐藏左右按钮。</h4><h4 id="_2-点击右侧按钮一次-图片往左播放一张-以此类推-左侧按钮同理。" tabindex="-1"><a class="header-anchor" href="#_2-点击右侧按钮一次-图片往左播放一张-以此类推-左侧按钮同理。" aria-hidden="true">#</a> 2.点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。</h4><h4 id="_3-图片播放的同时-下面小圆圈模块跟随一起变化。" tabindex="-1"><a class="header-anchor" href="#_3-图片播放的同时-下面小圆圈模块跟随一起变化。" aria-hidden="true">#</a> 3.图片播放的同时，下面小圆圈模块跟随一起变化。</h4><h4 id="_4-点击小圆圈-可以播放相应图片。" tabindex="-1"><a class="header-anchor" href="#_4-点击小圆圈-可以播放相应图片。" aria-hidden="true">#</a> 4.点击小圆圈，可以播放相应图片。</h4><h4 id="_5-鼠标不经过轮播图-轮播图也会自动播放图片。" tabindex="-1"><a class="header-anchor" href="#_5-鼠标不经过轮播图-轮播图也会自动播放图片。" aria-hidden="true">#</a> 5.鼠标不经过轮播图，轮播图也会自动播放图片。</h4><h4 id="_6-鼠标经过-轮播图模块-自动播放停止。" tabindex="-1"><a class="header-anchor" href="#_6-鼠标经过-轮播图模块-自动播放停止。" aria-hidden="true">#</a> 6.鼠标经过，轮播图模块， 自动播放停止。</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>function animate(obj, target, callback) {
// console.log(callback);  callback = function() {}  调用的时候 callback()
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="先清除以前的定时器-只保留当前的一个定时器执行" tabindex="-1"><a class="header-anchor" href="#先清除以前的定时器-只保留当前的一个定时器执行" aria-hidden="true">#</a> // 先清除以前的定时器，只保留当前的一个定时器执行</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>clearInterval(obj.timer);
obj.timer = setInterval(function() {
// 步长值写到定时器的里面
// 把我们步长值改为整数 不要出现小数的问题
// var step = Math.ceil((target ­ obj.offsetLeft) / 10);
var step = (target ­ obj.offsetLeft) /  10 ;
step = step &gt;  0 ? Math.ceil(step) : Math.floor(step);
if (obj.offsetLeft == target) {
// 停止动画 本质是停止定时器
clearInterval(obj.timer);
// 回调函数写到定时器结束里面
// if (callback) {
//     // 调用函数
//     callback();
// }
callback &amp;&amp; callback();
        }
// 把每次加 1  这个步长值改为一个慢慢变小的值 步长公式：(目标值 ­ 现在的位置) / 
obj.style.left = obj.offsetLeft + step + &#39;px&#39;;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="_15" tabindex="-1"><a class="header-anchor" href="#_15" aria-hidden="true">#</a> },  15 );</h5><h5 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> }</h5><p>window.addEventListener(&#39;load&#39;, function() {     // 1. 获取元素     var arrow_l = document.querySelector(&#39;.arrow­l&#39;);     var arrow_r = document.querySelector(&#39;.arrow­r&#39;);     var focus = document.querySelector(&#39;.focus&#39;);     var focusWidth = focus.offsetWidth;     // 2. 鼠标经过focus 就显示隐藏左右按钮     focus.addEventListener(&#39;mouseenter&#39;, function() {         arrow_l.style.display = &#39;block&#39;;         arrow_r.style.display = &#39;block&#39;;         clearInterval(timer);         timer = null; // 清除定时器变量     });     focus.addEventListener(&#39;mouseleave&#39;, function() {         arrow_l.style.display = &#39;none&#39;;         arrow_r.style.display = &#39;none&#39;;         timer = setInterval(function() {             //手动调用点击事件             arrow_r.click();         }, 2000);     });     // 3. 动态生成小圆圈 有几张图片，我就生成几个小圆圈     var ul = focus.querySelector(&#39;ul&#39;);     var ol = focus.querySelector(&#39;.circle&#39;);     // console.log(ul.children.length);     for (var i = 0; i &lt; ul.children.length; i++) {         // 创建一个小li          var li = document.createElement(&#39;li&#39;);         // 记录当前小圆圈的索引号 通过自定义属性来做         li.setAttribute(&#39;index&#39;, i);         // 把小li插入到ol 里面         ol.appendChild(li);         // 4. 小圆圈的排他思想 我们可以直接在生成小圆圈的同时直接绑定点击事件         li.addEventListener(&#39;click&#39;, function() {             // 干掉所有人 把所有的小li 清除 current 类名             for (var i = 0; i &lt; ol.children.length; i++) {                 ol.children[i].className = &#39;&#39;;             }             // 留下我自己 当前的小li 设置current 类名             this.className = &#39;current&#39;;             // 5. 点击小圆圈，移动图片 当然移动的是 ul              // ul 的移动距离 小圆圈的索引号 乘以 图片的宽度 注意是负值             // 当我们点击了某个小li 就拿到当前小li 的索引号             var index = this.getAttribute(&#39;index&#39;);             // 当我们点击了某个小li 就要把这个li 的索引号给 num               num = index;             // 当我们点击了某个小li 就要把这个li 的索引号给 circle               circle = index;             // num = circle = index;             console.log(focusWidth);             console.log(index);</p><p>animate(ul, ­index * focusWidth);</p><h5 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-hidden="true">#</a> })</h5><h5 id="-2" tabindex="-1"><a class="header-anchor" href="#-2" aria-hidden="true">#</a> }</h5><p>// 把ol里面的第一个小li设置类名为 current     ol.children[0].className = &#39;current&#39;;     // 6. 克隆第一张图片(li)放到ul 最后面     var first = ul.children[0].cloneNode(true);     ul.appendChild(first);     // 7. 点击右侧按钮， 图片滚动一张     var num = 0;     // circle 控制小圆圈的播放     var circle = 0;     // flag 节流阀     var flag = true;     arrow_r.addEventListener(&#39;click&#39;, function() {         if (flag) {             flag = false; // 关闭节流阀             // 如果走到了最后复制的一张图片，此时 我们的ul 要快速复原 left 改为  0              if (num == ul.children.length ­ 1) {                 ul.style.left = 0;                 num = 0;             }             num++;             animate(ul, ­num * focusWidth, function() {                 flag = true; // 打开节流阀             });             // 8. 点击右侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放             circle++;             // 如果circle == 4 说明走到最后我们克隆的这张图片了 我们就复原             if (circle == ol.children.length) {                 circle = 0;             }             // 调用函数             circleChange();         }     });</p><h5 id="_9-左侧按钮做法" tabindex="-1"><a class="header-anchor" href="#_9-左侧按钮做法" aria-hidden="true">#</a> // 9. 左侧按钮做法</h5><p>arrow_l.addEventListener(&#39;click&#39;, function() {         if (flag) {             flag = false;             if (num == 0) {                 num = ul.children.length ­ 1;                 ul.style.left = ­num * focusWidth + &#39;px&#39;;</p><h5 id="-3" tabindex="-1"><a class="header-anchor" href="#-3" aria-hidden="true">#</a> }</h5><p>num­­;             animate(ul, ­num * focusWidth, function() {                 flag = true;             });             // 点击左侧按钮，小圆圈跟随一起变化 可以再声明一个变量控制小圆圈的播放             circle­­;             // 如果circle &lt; 0  说明第一张图片，则小圆圈要改为第 4 个小圆圈（ 3 ）             // if (circle &lt; 0) {</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>            //     circle = ol.children.length ­ 1;
            // }
            circle = circle &lt; 0 ? ol.children.length ­ 1 : circle;
            // 调用函数
            circleChange();
        }
    });
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>    function circleChange() {
        // 先清除其余小圆圈的current类名
        for (var i = 0; i &lt; ol.children.length; i++) {
            ol.children[i].className = &#39;&#39;;
        }
        // 留下当前的小圆圈的current类名
        ol.children[circle].className = &#39;current&#39;;
    }
    // 10. 自动播放轮播图
    var timer = setInterval(function() {
        //手动调用点击事件
        arrow_r.click();
    }, 2000);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="-4" tabindex="-1"><a class="header-anchor" href="#-4" aria-hidden="true">#</a> })</h5><h3 id="_1-2-2-节流阀" tabindex="-1"><a class="header-anchor" href="#_1-2-2-节流阀" aria-hidden="true">#</a> 1.2.2. 节流阀</h3><h4 id="防止轮播图按钮连续点击造成播放过快。" tabindex="-1"><a class="header-anchor" href="#防止轮播图按钮连续点击造成播放过快。" aria-hidden="true">#</a> 防止轮播图按钮连续点击造成播放过快。</h4><h4 id="节流阀目的-当上一个函数动画内容执行完毕-再去执行下一个函数动画-让事件无法连续触发。" tabindex="-1"><a class="header-anchor" href="#节流阀目的-当上一个函数动画内容执行完毕-再去执行下一个函数动画-让事件无法连续触发。" aria-hidden="true">#</a> 节流阀目的：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</h4><h4 id="核心实现思路-利用回调函数-添加一个变量来控制-锁住函数和解锁函数。" tabindex="-1"><a class="header-anchor" href="#核心实现思路-利用回调函数-添加一个变量来控制-锁住函数和解锁函数。" aria-hidden="true">#</a> 核心实现思路：利用回调函数，添加一个变量来控制，锁住函数和解锁函数。</h4><h4 id="开始设置一个变量var-flag-true" tabindex="-1"><a class="header-anchor" href="#开始设置一个变量var-flag-true" aria-hidden="true">#</a> 开始设置一个变量var flag= true;</h4><h4 id="if-flag-flag-false-do-something-关闭水龙头" tabindex="-1"><a class="header-anchor" href="#if-flag-flag-false-do-something-关闭水龙头" aria-hidden="true">#</a> If(flag){flag = false; do something}       关闭水龙头</h4><h4 id="利用回调函数动画执行完毕-flag-true-打开水龙头" tabindex="-1"><a class="header-anchor" href="#利用回调函数动画执行完毕-flag-true-打开水龙头" aria-hidden="true">#</a> 利用回调函数动画执行完毕， flag = true     打开水龙头</h4><h3 id="_1-2-3-案例-返回顶部" tabindex="-1"><a class="header-anchor" href="#_1-2-3-案例-返回顶部" aria-hidden="true">#</a> 1.2.3. 案例：返回顶部</h3><h4 id="_1-带有动画的返回顶部" tabindex="-1"><a class="header-anchor" href="#_1-带有动画的返回顶部" aria-hidden="true">#</a> 1. 带有动画的返回顶部</h4><h4 id="_2-此时可以继续使用我们封装的动画函数" tabindex="-1"><a class="header-anchor" href="#_2-此时可以继续使用我们封装的动画函数" aria-hidden="true">#</a> 2. 此时可以继续使用我们封装的动画函数</h4><h4 id="_3-只需要把所有的left-相关的值改为-跟-页面垂直滚动距离相关就可以了" tabindex="-1"><a class="header-anchor" href="#_3-只需要把所有的left-相关的值改为-跟-页面垂直滚动距离相关就可以了" aria-hidden="true">#</a> 3. 只需要把所有的left 相关的值改为 跟 页面垂直滚动距离相关就可以了</h4><h4 id="_4-页面滚动了多少-可以通过-window-pageyoffset-得到" tabindex="-1"><a class="header-anchor" href="#_4-页面滚动了多少-可以通过-window-pageyoffset-得到" aria-hidden="true">#</a> 4. 页面滚动了多少，可以通过 window.pageYOffset 得到</h4><h4 id="_5-最后是页面滚动-使用-window-scroll-x-y" tabindex="-1"><a class="header-anchor" href="#_5-最后是页面滚动-使用-window-scroll-x-y" aria-hidden="true">#</a> 5. 最后是页面滚动，使用 window.scroll(x,y)</h4><h3 id="_1-2-4-案例-筋头云案例" tabindex="-1"><a class="header-anchor" href="#_1-2-4-案例-筋头云案例" aria-hidden="true">#</a> 1.2.4. 案例：筋头云案例</h3><h5 id="_1-获取元素" tabindex="-1"><a class="header-anchor" href="#_1-获取元素" aria-hidden="true">#</a> //1. 获取元素</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>var sliderbar = document.querySelector(&#39;.slider­bar&#39;);
var banner = document.querySelector(&#39;.banner&#39;);
// banner.offestTop 就是被卷去头部的大小 一定要写到滚动的外面
var bannerTop = banner.offsetTop
// 当我们侧边栏固定定位之后应该变化的数值
var sliderbarTop = sliderbar.offsetTop ­ bannerTop;
// 获取main 主体元素
var main = document.querySelector(&#39;.main&#39;);
var goBack = document.querySelector(&#39;.goBack&#39;);
var mainTop = main.offsetTop;
// 2. 页面滚动事件 scroll
document.addEventListener(&#39;scroll&#39;, function() {
// console.log(11);
// window.pageYOffset 页面被卷去的头部
// console.log(window.pageYOffset);
// 3 .当我们页面被卷去的头部大于等于了  172  此时 侧边栏就要改为固定定位
if (window.pageYOffset &gt;= bannerTop) {
sliderbar.style.position = &#39;fixed&#39;;
sliderbar.style.top = sliderbarTop + &#39;px&#39;;
                } else {
sliderbar.style.position = &#39;absolute&#39;;
sliderbar.style.top = &#39;300px&#39;;
                }
// 4. 当我们页面滚动到main盒子，就显示 goback模块
if (window.pageYOffset &gt;= mainTop) {
goBack.style.display = &#39;block&#39;;
                } else {
goBack.style.display = &#39;none&#39;;
                }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="-5" tabindex="-1"><a class="header-anchor" href="#-5" aria-hidden="true">#</a> })</h5><h5 id="_3-当我们点击了返回顶部模块-就让窗口滚动的页面的最上方" tabindex="-1"><a class="header-anchor" href="#_3-当我们点击了返回顶部模块-就让窗口滚动的页面的最上方" aria-hidden="true">#</a> // 3. 当我们点击了返回顶部模块，就让窗口滚动的页面的最上方</h5><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>goBack.addEventListener(&#39;click&#39;, function() {
// 里面的x和y 不跟单位的 直接写数字即可
// window.scroll(0, 0);
// 因为是窗口滚动 所以对象是window
animate(window,  0 );
        });
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_1-利用动画函数做动画效果" tabindex="-1"><a class="header-anchor" href="#_1-利用动画函数做动画效果" aria-hidden="true">#</a> 1. 利用动画函数做动画效果</h4><h4 id="_2-原先筋斗云的起始位置是-0" tabindex="-1"><a class="header-anchor" href="#_2-原先筋斗云的起始位置是-0" aria-hidden="true">#</a> 2. 原先筋斗云的起始位置是 0</h4><h4 id="_3-鼠标经过某个小li-把当前小li的offsetleft-位置做为目标值即可" tabindex="-1"><a class="header-anchor" href="#_3-鼠标经过某个小li-把当前小li的offsetleft-位置做为目标值即可" aria-hidden="true">#</a> 3. 鼠标经过某个小li，把当前小li的offsetLeft 位置做为目标值即可</h4><h4 id="_4-鼠标离开某个小li-就把目标值设为-0" tabindex="-1"><a class="header-anchor" href="#_4-鼠标离开某个小li-就把目标值设为-0" aria-hidden="true">#</a> 4. 鼠标离开某个小li，就把目标值设为 0</h4><h4 id="_5-如果点击了某个小li-就把li当前的位置存储起来-做为筋斗云的起始位置" tabindex="-1"><a class="header-anchor" href="#_5-如果点击了某个小li-就把li当前的位置存储起来-做为筋斗云的起始位置" aria-hidden="true">#</a> 5. 如果点击了某个小li， 就把li当前的位置存储起来，做为筋斗云的起始位置</h4><h2 id="_1-3-触屏事件" tabindex="-1"><a class="header-anchor" href="#_1-3-触屏事件" aria-hidden="true">#</a> 1.3. 触屏事件</h2><h3 id="_1-3-1-触屏事件概述" tabindex="-1"><a class="header-anchor" href="#_1-3-1-触屏事件概述" aria-hidden="true">#</a> 1.3.1. 触屏事件概述</h3><h4 id="移动端浏览器兼容性较好-我们不需要考虑以前-js-的兼容性问题-可以放心的使用原生-js-书写效果-但是移动端" tabindex="-1"><a class="header-anchor" href="#移动端浏览器兼容性较好-我们不需要考虑以前-js-的兼容性问题-可以放心的使用原生-js-书写效果-但是移动端" aria-hidden="true">#</a> 移动端浏览器兼容性较好，我们不需要考虑以前 JS 的兼容性问题，可以放心的使用原生 JS 书写效果，但是移动端</h4><h4 id="也有自己独特的地方。比如触屏事件-touch-也称触摸事件-android和-ios-都有。" tabindex="-1"><a class="header-anchor" href="#也有自己独特的地方。比如触屏事件-touch-也称触摸事件-android和-ios-都有。" aria-hidden="true">#</a> 也有自己独特的地方。比如触屏事件 touch（也称触摸事件），Android和 IOS 都有。</h4><h4 id="touch-对象代表一个触摸点。触摸点可能是一根手指-也可能是一根触摸笔。触屏事件可响应用户手指-或触控" tabindex="-1"><a class="header-anchor" href="#touch-对象代表一个触摸点。触摸点可能是一根手指-也可能是一根触摸笔。触屏事件可响应用户手指-或触控" aria-hidden="true">#</a> touch 对象代表一个触摸点。触摸点可能是一根手指，也可能是一根触摸笔。触屏事件可响应用户手指（或触控</h4><h4 id="笔-对屏幕或者触控板操作。" tabindex="-1"><a class="header-anchor" href="#笔-对屏幕或者触控板操作。" aria-hidden="true">#</a> 笔）对屏幕或者触控板操作。</h4><h4 id="常见的触屏事件如下" tabindex="-1"><a class="header-anchor" href="#常见的触屏事件如下" aria-hidden="true">#</a> 常见的触屏事件如下：</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>window.addEventListener(&#39;load&#39;, function() {
// 1. 获取元素
var cloud = document.querySelector(&#39;.cloud&#39;);
var c_nav = document.querySelector(&#39;.c­nav&#39;);
var lis = c_nav.querySelectorAll(&#39;li&#39;);
// 2. 给所有的小li绑定事件
// 这个current 做为筋斗云的起始位置
var current =  0 ;
for (var i =  0 ; i &lt; lis.length; i++) {
// (1) 鼠标经过把当前小li 的位置做为目标值
lis[i].addEventListener(&#39;mouseenter&#39;, function() {
animate(cloud, this.offsetLeft);
                });
// (2) 鼠标离开就回到起始的位置
lis[i].addEventListener(&#39;mouseleave&#39;, function() {
animate(cloud, current);
                });
// (3) 当我们鼠标点击，就把当前位置做为目标值
lis[i].addEventListener(&#39;click&#39;, function() {
current = this.offsetLeft;
                });
            }
        })
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-3-2-触摸事件对象-touchevent" tabindex="-1"><a class="header-anchor" href="#_1-3-2-触摸事件对象-touchevent" aria-hidden="true">#</a> 1.3.2. 触摸事件对象（TouchEvent）</h3><h4 id="touchevent-是一类描述手指在触摸平面-触摸屏、触摸板等-的状态变化的事件。这类事件用于描述一个或多个" tabindex="-1"><a class="header-anchor" href="#touchevent-是一类描述手指在触摸平面-触摸屏、触摸板等-的状态变化的事件。这类事件用于描述一个或多个" aria-hidden="true">#</a> TouchEvent 是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件。这类事件用于描述一个或多个</h4><h4 id="触点-使开发者可以检测触点的移动-触点的增加和减少-等等" tabindex="-1"><a class="header-anchor" href="#触点-使开发者可以检测触点的移动-触点的增加和减少-等等" aria-hidden="true">#</a> 触点，使开发者可以检测触点的移动，触点的增加和减少，等等</h4><h4 id="touchstart、touchmove、touchend-三个事件都会各自有事件对象。" tabindex="-1"><a class="header-anchor" href="#touchstart、touchmove、touchend-三个事件都会各自有事件对象。" aria-hidden="true">#</a> touchstart、touchmove、touchend 三个事件都会各自有事件对象。</h4><h4 id="触摸事件对象重点我们看三个常见对象列表" tabindex="-1"><a class="header-anchor" href="#触摸事件对象重点我们看三个常见对象列表" aria-hidden="true">#</a> 触摸事件对象重点我们看三个常见对象列表：</h4><h4 id="图片-2" tabindex="-1"><a class="header-anchor" href="#图片-2" aria-hidden="true">#</a> 图片 2</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>因为平时我们都是给元素注册触摸事件，所以重点记住 targetTocuhes
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_1-3-3-案例-移动端拖动元素" tabindex="-1"><a class="header-anchor" href="#_1-3-3-案例-移动端拖动元素" aria-hidden="true">#</a> 1.3.3.案例：移动端拖动元素</h3><h4 id="_1-touchstart、touchmove、touchend可以实现拖动元素" tabindex="-1"><a class="header-anchor" href="#_1-touchstart、touchmove、touchend可以实现拖动元素" aria-hidden="true">#</a> 1. touchstart、touchmove、touchend可以实现拖动元素</h4><h4 id="_2-但是拖动元素需要当前手指的坐标值-我们可以使用-targettouches-0-里面的pagex-和-pagey" tabindex="-1"><a class="header-anchor" href="#_2-但是拖动元素需要当前手指的坐标值-我们可以使用-targettouches-0-里面的pagex-和-pagey" aria-hidden="true">#</a> 2. 但是拖动元素需要当前手指的坐标值 我们可以使用  targetTouches[0] 里面的pageX 和 pageY</h4><h4 id="_3-移动端拖动的原理-手指移动中-计算出手指移动的距离。然后用盒子原来的位置-手指移动的距离" tabindex="-1"><a class="header-anchor" href="#_3-移动端拖动的原理-手指移动中-计算出手指移动的距离。然后用盒子原来的位置-手指移动的距离" aria-hidden="true">#</a> 3. 移动端拖动的原理： 手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离</h4><h4 id="_4-手指移动的距离-手指滑动中的位置-减去-手指刚开始触摸的位置" tabindex="-1"><a class="header-anchor" href="#_4-手指移动的距离-手指滑动中的位置-减去-手指刚开始触摸的位置" aria-hidden="true">#</a> 4. 手指移动的距离： 手指滑动中的位置 减去 手指刚开始触摸的位置</h4><h4 id="拖动元素三步曲" tabindex="-1"><a class="header-anchor" href="#拖动元素三步曲" aria-hidden="true">#</a> 拖动元素三步曲：</h4><h4 id="_1-触摸元素-touchstart-获取手指初始坐标-同时获得盒子原来的位置" tabindex="-1"><a class="header-anchor" href="#_1-触摸元素-touchstart-获取手指初始坐标-同时获得盒子原来的位置" aria-hidden="true">#</a> （ 1 ） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置</h4><h4 id="_2-移动手指-touchmove-计算手指的滑动距离-并且移动盒子" tabindex="-1"><a class="header-anchor" href="#_2-移动手指-touchmove-计算手指的滑动距离-并且移动盒子" aria-hidden="true">#</a> （ 2 ） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子</h4><h4 id="_3-离开手指-touchend" tabindex="-1"><a class="header-anchor" href="#_3-离开手指-touchend" aria-hidden="true">#</a> （ 3 ） 离开手指 touchend:</h4><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,102),l=[r];function h(s,t){return a(),i("div",null,l)}const o=e(d,[["render",h],["__file","06-webapis.html.vue"]]);export{o as default};
